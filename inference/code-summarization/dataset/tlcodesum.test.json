{"id": "15495", "raw_code": "private int currentDepth(){\n  try {\n    Integer oneBased=((Integer)DEPTH_FIELD.get(this));\n    return oneBased - 1;\n  }\n catch (  IllegalAccessException e) {\n    throw new AssertionError(e);\n  }\n}\n", "raw_comment": " Returns a 0-based depth within the object graph of the current object being serialized.", "code": "private int currentDepth ( ) { try { Integer oneBased = ( ( Integer ) DEPTH_FIELD . get ( this ) ) ; return oneBased - _NUM ; } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } }\n", "comment": "returns a 0 - based depth within the object graph of the current object being serialized ."}
{"id": "37963", "raw_code": "protected boolean[] datasetIntegrity(boolean nominalPredictor,boolean numericPredictor,boolean stringPredictor,boolean datePredictor,boolean relationalPredictor,boolean multiInstance,int classType,boolean predictorMissing,boolean classMissing){\n  print(\"kernel doesn't alter original datasets\");\n  printAttributeSummary(nominalPredictor,numericPredictor,stringPredictor,datePredictor,relationalPredictor,multiInstance,classType);\n  print(\"...\");\n  int numTrain=getNumInstances(), numClasses=2, missingLevel=20;\n  boolean[] result=new boolean[2];\n  Instances train=null;\n  Kernel kernel=null;\n  try {\n    train=makeTestDataset(42,numTrain,nominalPredictor ? getNumNominal() : 0,numericPredictor ? getNumNumeric() : 0,stringPredictor ? getNumString() : 0,datePredictor ? getNumDate() : 0,relationalPredictor ? getNumRelational() : 0,numClasses,classType,multiInstance);\n    if (missingLevel > 0) {\n      addMissing(train,missingLevel,predictorMissing,classMissing);\n    }\n    kernel=Kernel.makeCopies(getKernel(),1)[0];\n  }\n catch (  Exception ex) {\n    throw new Error(\"Error setting up for tests: \" + ex.getMessage());\n  }\n  try {\n    Instances trainCopy=new Instances(train);\n    kernel.buildKernel(trainCopy);\n    compareDatasets(train,trainCopy);\n    println(\"yes\");\n    result[0]=true;\n  }\n catch (  Exception ex) {\n    println(\"no\");\n    result[0]=false;\n    if (m_Debug) {\n      println(\"\\n=== Full Report ===\");\n      print(\"Problem during building\");\n      println(\": \" + ex.getMessage() + \"\\n\");\n      println(\"Here is the dataset:\\n\");\n      println(\"=== Train Dataset ===\\n\" + train.toString() + \"\\n\");\n    }\n  }\n  return result;\n}\n", "raw_comment": " Checks whether the scheme alters the training dataset during building. If the scheme needs to modify the data it should take a copy of the training data. Currently checks for changes to header structure, number of instances, order of instances, instance weights.", "code": "protected boolean [ ] datasetIntegrity ( boolean nominalPredictor , boolean numericPredictor , boolean stringPredictor , boolean datePredictor , boolean relationalPredictor , boolean multiInstance , int classType , boolean predictorMissing , boolean classMissing ) { print ( _STR ) ; printAttributeSummary ( nominalPredictor , numericPredictor , stringPredictor , datePredictor , relationalPredictor , multiInstance , classType ) ; print ( _STR ) ; int numTrain = getNumInstances ( ) , numClasses = _NUM , missingLevel = _NUM ; boolean [ ] result = new boolean [ _NUM ] ; Instances train = null ; Kernel kernel = null ; try { train = makeTestDataset ( _NUM , numTrain , nominalPredictor ? getNumNominal ( ) : _NUM , numericPredictor ? getNumNumeric ( ) : _NUM , stringPredictor ? getNumString ( ) : _NUM , datePredictor ? getNumDate ( ) : _NUM , relationalPredictor ? getNumRelational ( ) : _NUM , numClasses , classType , multiInstance ) ; if ( missingLevel > _NUM ) { addMissing ( train , missingLevel , predictorMissing , classMissing ) ; } kernel = Kernel . makeCopies ( getKernel ( ) , _NUM ) [ _NUM ] ; } catch ( Exception ex ) { throw new Error ( _STR + ex . getMessage ( ) ) ; } try { Instances trainCopy = new Instances ( train ) ; kernel . buildKernel ( trainCopy ) ; compareDatasets ( train , trainCopy ) ; println ( _STR ) ; result [ _NUM ] = _BOOL ; } catch ( Exception ex ) { println ( _STR ) ; result [ _NUM ] = _BOOL ; if ( m_Debug ) { println ( _STR ) ; print ( _STR ) ; println ( _STR + ex . getMessage ( ) + _STR ) ; println ( _STR ) ; println ( _STR + train . toString ( ) + _STR ) ; } } return result ; }\n", "comment": "checks whether the scheme alters the training dataset during building ."}
{"id": "53306", "raw_code": "public static int unionSize(long[] x,long[] y){\n  final int lx=x.length, ly=y.length;\n  final int min=(lx < ly) ? lx : ly;\n  int i=0, res=0;\n  for (; i < min; i++) {\n    res+=Long.bitCount(x[i] | y[i]);\n  }\n  for (; i < lx; i++) {\n    res+=Long.bitCount(x[i]);\n  }\n  for (; i < ly; i++) {\n    res+=Long.bitCount(y[i]);\n  }\n  return res;\n}\n", "raw_comment": " Compute the union size of two Bitsets.", "code": "public static int unionSize ( long [ ] x , long [ ] y ) { final int lx = x . length , ly = y . length ; final int min = ( lx < ly ) ? lx : ly ; int i = _NUM , res = _NUM ; for ( ; i < min ; i ++ ) { res += Long . bitCount ( x [ i ] | y [ i ] ) ; } for ( ; i < lx ; i ++ ) { res += Long . bitCount ( x [ i ] ) ; } for ( ; i < ly ; i ++ ) { res += Long . bitCount ( y [ i ] ) ; } return res ; }\n", "comment": "compute the union size of two bitsets ."}
{"id": "38468", "raw_code": "@Override public void closingOK(){\n  List<AddUserFields.AttributeSpec> specs=new ArrayList<AddUserFields.AttributeSpec>();\n  for (int i=0; i < m_listModel.size(); i++) {\n    AddUserFields.AttributeSpec a=(AddUserFields.AttributeSpec)m_listModel.elementAt(i);\n    specs.add(a);\n  }\n  if (m_modifyL != null) {\n    m_modifyL.setModifiedStatus(AddUserFieldsCustomizer.this,true);\n  }\n  m_filter.setAttributeSpecs(specs);\n}\n", "raw_comment": " Actions to perform when the user has closed the dialog with the OK button.", "code": "@ Override public void closingOK ( ) { List < AddUserFields . AttributeSpec > specs = new ArrayList < AddUserFields . AttributeSpec > ( ) ; for ( int i = _NUM ; i < m_listModel . size ( ) ; i ++ ) { AddUserFields . AttributeSpec a = ( AddUserFields . AttributeSpec ) m_listModel . elementAt ( i ) ; specs . add ( a ) ; } if ( m_modifyL != null ) { m_modifyL . setModifiedStatus ( AddUserFieldsCustomizer . this , _BOOL ) ; } m_filter . setAttributeSpecs ( specs ) ; }\n", "comment": "actions to perform when the user has closed the dialog with the ok button ."}
{"id": "27016", "raw_code": "public final Sector union(Sector that){\n  if (that == null)   return this;\n  Angle minLat=this.minLatitude;\n  Angle maxLat=this.maxLatitude;\n  Angle minLon=this.minLongitude;\n  Angle maxLon=this.maxLongitude;\n  if (that.minLatitude.degrees < this.minLatitude.degrees)   minLat=that.minLatitude;\n  if (that.maxLatitude.degrees > this.maxLatitude.degrees)   maxLat=that.maxLatitude;\n  if (that.minLongitude.degrees < this.minLongitude.degrees)   minLon=that.minLongitude;\n  if (that.maxLongitude.degrees > this.maxLongitude.degrees)   maxLon=that.maxLongitude;\n  return new Sector(minLat,maxLat,minLon,maxLon);\n}\n", "raw_comment": " Returns a new sector whose angles are the extremes of the this sector and another. The new sector's minimum latitude and longitude will be the minimum of the two sectors. The new sector's maximum latitude and longitude will be the maximum of the two sectors. The sectors are assumed to be normalized to +/- 90 degrees latitude and +/- 180 degrees longitude. The result of the operation is undefined if they are not.", "code": "public final Sector union ( Sector that ) { if ( that == null ) return this ; Angle minLat = this . minLatitude ; Angle maxLat = this . maxLatitude ; Angle minLon = this . minLongitude ; Angle maxLon = this . maxLongitude ; if ( that . minLatitude . degrees < this . minLatitude . degrees ) minLat = that . minLatitude ; if ( that . maxLatitude . degrees > this . maxLatitude . degrees ) maxLat = that . maxLatitude ; if ( that . minLongitude . degrees < this . minLongitude . degrees ) minLon = that . minLongitude ; if ( that . maxLongitude . degrees > this . maxLongitude . degrees ) maxLon = that . maxLongitude ; return new Sector ( minLat , maxLat , minLon , maxLon ) ; }\n", "comment": "returns a new sector whose angles are the extremes of the this sector and another ."}
{"id": "20101", "raw_code": "private static boolean isDoubleEqual(double value,double valueToCompare){\n  return (Math.abs(value - valueToCompare) < 0.001);\n}\n", "raw_comment": " Checks if is double values are equal.", "code": "private static boolean isDoubleEqual ( double value , double valueToCompare ) { return ( Math . abs ( value - valueToCompare ) < _NUM ) ; }\n", "comment": "checks if is double values are equal ."}
{"id": "64161", "raw_code": "private void walk(File directory,int depth,Collection<T> results) throws IOException {\n  checkIfCancelled(directory,depth,results);\n  if (handleDirectory(directory,depth,results)) {\n    handleDirectoryStart(directory,depth,results);\n    int childDepth=depth + 1;\n    if (depthLimit < 0 || childDepth <= depthLimit) {\n      checkIfCancelled(directory,depth,results);\n      File[] childFiles=filter == null ? directory.listFiles() : directory.listFiles(filter);\n      childFiles=filterDirectoryContents(directory,depth,childFiles);\n      if (childFiles == null) {\n        handleRestricted(directory,childDepth,results);\n      }\n else {\n        for (        File childFile : childFiles) {\n          if (childFile.isDirectory()) {\n            walk(childFile,childDepth,results);\n          }\n else {\n            checkIfCancelled(childFile,childDepth,results);\n            handleFile(childFile,childDepth,results);\n            checkIfCancelled(childFile,childDepth,results);\n          }\n        }\n      }\n    }\n    handleDirectoryEnd(directory,depth,results);\n  }\n  checkIfCancelled(directory,depth,results);\n}\n", "raw_comment": " Main recursive method to examine the directory hierarchy.", "code": "private void walk ( File directory , int depth , Collection < T > results ) throws IOException { checkIfCancelled ( directory , depth , results ) ; if ( handleDirectory ( directory , depth , results ) ) { handleDirectoryStart ( directory , depth , results ) ; int childDepth = depth + _NUM ; if ( depthLimit < _NUM || childDepth <= depthLimit ) { checkIfCancelled ( directory , depth , results ) ; File [ ] childFiles = filter == null ? directory . listFiles ( ) : directory . listFiles ( filter ) ; childFiles = filterDirectoryContents ( directory , depth , childFiles ) ; if ( childFiles == null ) { handleRestricted ( directory , childDepth , results ) ; } else { for ( File childFile : childFiles ) { if ( childFile . isDirectory ( ) ) { walk ( childFile , childDepth , results ) ; } else { checkIfCancelled ( childFile , childDepth , results ) ; handleFile ( childFile , childDepth , results ) ; checkIfCancelled ( childFile , childDepth , results ) ; } } } } handleDirectoryEnd ( directory , depth , results ) ; } checkIfCancelled ( directory , depth , results ) ; }\n", "comment": "main recursive method to examine the directory hierarchy ."}
{"id": "63817", "raw_code": "public static Object[] ordinalArray(TupleSet tuples,String field){\n  return ordinalArray(tuples,field,DefaultLiteralComparator.getInstance());\n}\n", "raw_comment": " Get a sorted array containing all column values for a given tuple iterator and field.", "code": "public static Object [ ] ordinalArray ( TupleSet tuples , String field ) { return ordinalArray ( tuples , field , DefaultLiteralComparator . getInstance ( ) ) ; }\n", "comment": "get a sorted array containing all column values for a given tuple iterator and field ."}
{"id": "7488", "raw_code": "@Override public void datasetChanged(DatasetChangeEvent event){\n  super.datasetChanged(event);\n  if (this.subplots == null) {\n    return;\n  }\n  XYDataset dataset=null;\n  if (event.getDataset() instanceof XYDataset) {\n    dataset=(XYDataset)event.getDataset();\n  }\n  for (  XYPlot subplot : this.subplots) {\n    if (subplot.indexOf(dataset) >= 0) {\n      subplot.configureRangeAxes();\n    }\n  }\n}\n", "raw_comment": " Receives notification of a change to the plot's dataset. <P> The axis ranges are updated if necessary.", "code": "@ Override public void datasetChanged ( DatasetChangeEvent event ) { super . datasetChanged ( event ) ; if ( this . subplots == null ) { return ; } XYDataset dataset = null ; if ( event . getDataset ( ) instanceof XYDataset ) { dataset = ( XYDataset ) event . getDataset ( ) ; } for ( XYPlot subplot : this . subplots ) { if ( subplot . indexOf ( dataset ) >= _NUM ) { subplot . configureRangeAxes ( ) ; } } }\n", "comment": "receives notification of a change to the plot ' s dataset ."}
{"id": "26930", "raw_code": "public boolean onScheduleAsLibrary(Config config,Config runtime,IScheduler scheduler,PackingPlan packing){\n  boolean ret=false;\n  try {\n    scheduler.initialize(config,runtime);\n    ret=scheduler.onSchedule(packing);\n    if (ret) {\n      ret=SchedulerUtils.setLibSchedulerLocation(runtime,scheduler,false);\n    }\n else {\n      LOG.severe(\"Failed to invoke IScheduler as library\");\n    }\n  }\n  finally {\n    scheduler.close();\n  }\n  return ret;\n}\n", "raw_comment": " Invoke the onScheduler() in IScheduler directly as a library", "code": "public boolean onScheduleAsLibrary ( Config config , Config runtime , IScheduler scheduler , PackingPlan packing ) { boolean ret = _BOOL ; try { scheduler . initialize ( config , runtime ) ; ret = scheduler . onSchedule ( packing ) ; if ( ret ) { ret = SchedulerUtils . setLibSchedulerLocation ( runtime , scheduler , _BOOL ) ; } else { LOG . severe ( _STR ) ; } } finally { scheduler . close ( ) ; } return ret ; }\n", "comment": "invoke the onscheduler ( ) in ischeduler directly as a library"}
{"id": "66883", "raw_code": "public static boolean isStringType(Type t){\n  return t.equals(RefType.v(\"java.lang.String\"));\n}\n", "raw_comment": " Returns true if specified type is Java.lang.String ", "code": "public static boolean isStringType ( Type t ) { return t . equals ( RefType . v ( _STR ) ) ; }\n", "comment": "returns true if specified type is java . lang . string"}
{"id": "56795", "raw_code": "private void validateSqlStatement(String sql,int jdbcStatementIndex){\n  Assert.isTrue(StringUtils.isNotBlank(sql),\"JDBC statement [\" + jdbcStatementIndex + \"] SQL is required\");\n}\n", "raw_comment": " Validates the given SQL statement where its position in the list of statement is the given index. This method does not validate SQL syntax.", "code": "private void validateSqlStatement ( String sql , int jdbcStatementIndex ) { Assert . isTrue ( StringUtils . isNotBlank ( sql ) , _STR + jdbcStatementIndex + _STR ) ; }\n", "comment": "validates the given sql statement where its position in the list of statement is the given index ."}
{"id": "10150", "raw_code": "public static Long[] valuesOf(long[] array){\n  Long[] dest=new Long[array.length];\n  for (int i=0; i < array.length; i++) {\n    dest[i]=Long.valueOf(array[i]);\n  }\n  return dest;\n}\n", "raw_comment": " Converts to object array.", "code": "public static Long [ ] valuesOf ( long [ ] array ) { Long [ ] dest = new Long [ array . length ] ; for ( int i = _NUM ; i < array . length ; i ++ ) { dest [ i ] = Long . valueOf ( array [ i ] ) ; } return dest ; }\n", "comment": "converts to object array ."}
{"id": "80601", "raw_code": "private static void useMissile(Player player){\n  StackableItem projectilesItem=null;\n  if (player.getRangeWeapon() != null) {\n    projectilesItem=player.getAmmunition();\n  }\n  if (projectilesItem == null) {\n    projectilesItem=player.getMissileIfNotHoldingOtherWeapon();\n  }\n  if (projectilesItem != null) {\n    projectilesItem.removeOne();\n  }\n}\n", "raw_comment": " Remove an used up missile from an attacking player.", "code": "private static void useMissile ( Player player ) { StackableItem projectilesItem = null ; if ( player . getRangeWeapon ( ) != null ) { projectilesItem = player . getAmmunition ( ) ; } if ( projectilesItem == null ) { projectilesItem = player . getMissileIfNotHoldingOtherWeapon ( ) ; } if ( projectilesItem != null ) { projectilesItem . removeOne ( ) ; } }\n", "comment": "remove an used up missile from an attacking player ."}
{"id": "25383", "raw_code": "public TcpMatcher(final NetworkConfig config){\n  super(config);\n}\n", "raw_comment": " Creates a new matcher for running CoAP over TCP.", "code": "public TcpMatcher ( final NetworkConfig config ) { super ( config ) ; }\n", "comment": "creates a new matcher for running coap over tcp ."}
{"id": "20694", "raw_code": "private int determineMaxLevelRec(int level,Node v){\n  int newLevel=level;\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n    newLevel=Math.max(newLevel,determineMaxLevelRec(level,e.getTarget()) + 1);\n  }\n  return newLevel;\n}\n", "raw_comment": " recursively does the work", "code": "private int determineMaxLevelRec ( int level , Node v ) { int newLevel = level ; for ( Edge e = v . getFirstOutEdge ( ) ; e != null ; e = v . getNextOutEdge ( e ) ) { newLevel = Math . max ( newLevel , determineMaxLevelRec ( level , e . getTarget ( ) ) + _NUM ) ; } return newLevel ; }\n", "comment": "recursively does the work"}
{"id": "49452", "raw_code": "protected void requestPassCodeConfirmation(){\n  clearBoxes();\n  mPassCodeHdr.setText(R.string.pass_code_reenter_your_pass_code);\n  mPassCodeHdrExplanation.setVisibility(View.INVISIBLE);\n  mConfirmingPassCode=true;\n}\n", "raw_comment": " Ask to the user for retyping the pass code just entered before saving it as the current pass code.", "code": "protected void requestPassCodeConfirmation ( ) { clearBoxes ( ) ; mPassCodeHdr . setText ( R . string . pass_code_reenter_your_pass_code ) ; mPassCodeHdrExplanation . setVisibility ( View . INVISIBLE ) ; mConfirmingPassCode = _BOOL ; }\n", "comment": "ask to the user for retyping the pass code just entered before saving it as the current pass code ."}
{"id": "47090", "raw_code": "private void addWorkerFailed(Worker w){\n  final ReentrantLock mainLock=this.mainLock;\n  mainLock.lock();\n  try {\n    if (w != null)     workers.remove(w);\n    decrementWorkerCount();\n    tryTerminate();\n  }\n  finally {\n    mainLock.unlock();\n  }\n}\n", "raw_comment": " Rolls back the worker thread creation. - removes worker from workers, if present - decrements worker count - rechecks for termination, in case the existence of this worker was holding up termination", "code": "private void addWorkerFailed ( Worker w ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { if ( w != null ) workers . remove ( w ) ; decrementWorkerCount ( ) ; tryTerminate ( ) ; } finally { mainLock . unlock ( ) ; } }\n", "comment": "rolls back the worker thread creation ."}
{"id": "25997", "raw_code": "private synchronized void putMapEntry(String localId,MapEntry entry){\n  if (!isLocalId(localId)) {\n    throw new IllegalStateException(\"Tried to get invalid local id: \\\"\" + localId + \"\\\".\");\n  }\n  JSONObject json=new JSONObject();\n  try {\n    json.put(\"retainCount\",entry.retainCount);\n    if (entry.objectId != null) {\n      json.put(\"objectId\",entry.objectId);\n    }\n  }\n catch (  JSONException je) {\n    throw new IllegalStateException(\"Error creating local id map entry.\",je);\n  }\n  File file=new File(diskPath,localId);\n  if (!diskPath.exists()) {\n    diskPath.mkdirs();\n  }\n  try {\n    ParseFileUtils.writeJSONObjectToFile(file,json);\n  }\n catch (  IOException e) {\n  }\n}\n", "raw_comment": " Writes one entry to the local id map on disk.", "code": "private synchronized void putMapEntry ( String localId , MapEntry entry ) { if ( ! isLocalId ( localId ) ) { throw new IllegalStateException ( _STR + localId + _STR ) ; } JSONObject json = new JSONObject ( ) ; try { json . put ( _STR , entry . retainCount ) ; if ( entry . objectId != null ) { json . put ( _STR , entry . objectId ) ; } } catch ( JSONException je ) { throw new IllegalStateException ( _STR , je ) ; } File file = new File ( diskPath , localId ) ; if ( ! diskPath . exists ( ) ) { diskPath . mkdirs ( ) ; } try { ParseFileUtils . writeJSONObjectToFile ( file , json ) ; } catch ( IOException e ) { } }\n", "comment": "writes one entry to the local id map on disk ."}
{"id": "61349", "raw_code": "public void endElement(String namespaceURI,String localName,String name) throws org.xml.sax.SAXException {\n  if (m_inEntityRef)   return;\n  m_prefixMap.popNamespaces(m_elemContext.m_currentElemDepth,null);\n  try {\n    final java.io.Writer writer=m_writer;\n    if (m_elemContext.m_startTagOpen) {\n      if (m_tracer != null)       super.fireStartElem(m_elemContext.m_elementName);\n      int nAttrs=m_attributes.getLength();\n      if (nAttrs > 0) {\n        processAttributes(m_writer,nAttrs);\n        m_attributes.clear();\n      }\n      if (m_spaceBeforeClose)       writer.write(\" />\");\n else       writer.write(\"/>\");\n    }\n else {\n      if (m_cdataTagOpen)       closeCDATA();\n      if (shouldIndent())       indent(m_elemContext.m_currentElemDepth - 1);\n      writer.write('<');\n      writer.write('/');\n      writer.write(name);\n      writer.write('>');\n    }\n  }\n catch (  IOException e) {\n    throw new SAXException(e);\n  }\n  if (!m_elemContext.m_startTagOpen && m_doIndent) {\n    m_ispreserve=m_preserves.isEmpty() ? false : m_preserves.pop();\n  }\n  m_isprevtext=false;\n  if (m_tracer != null)   super.fireEndElem(name);\n  m_elemContext=m_elemContext.m_prev;\n}\n", "raw_comment": " Receive notification of the end of an element.", "code": "public void endElement ( String namespaceURI , String localName , String name ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; m_prefixMap . popNamespaces ( m_elemContext . m_currentElemDepth , null ) ; try { final java . io . Writer writer = m_writer ; if ( m_elemContext . m_startTagOpen ) { if ( m_tracer != null ) super . fireStartElem ( m_elemContext . m_elementName ) ; int nAttrs = m_attributes . getLength ( ) ; if ( nAttrs > _NUM ) { processAttributes ( m_writer , nAttrs ) ; m_attributes . clear ( ) ; } if ( m_spaceBeforeClose ) writer . write ( _STR ) ; else writer . write ( _STR ) ; } else { if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( shouldIndent ( ) ) indent ( m_elemContext . m_currentElemDepth - _NUM ) ; writer . write ( _STR ) ; writer . write ( _STR ) ; writer . write ( name ) ; writer . write ( _STR ) ; } } catch ( IOException e ) { throw new SAXException ( e ) ; } if ( ! m_elemContext . m_startTagOpen && m_doIndent ) { m_ispreserve = m_preserves . isEmpty ( ) ? _BOOL : m_preserves . pop ( ) ; } m_isprevtext = _BOOL ; if ( m_tracer != null ) super . fireEndElem ( name ) ; m_elemContext = m_elemContext . m_prev ; }\n", "comment": "receive notification of the end of an element ."}
{"id": "67965", "raw_code": "public static void f(String msg,Object... args){\n  if (!allowWtf)   return;\n  StackTraceElement caller=getCallerStackTraceElement();\n  String tag=generateTag(caller);\n  if (sLevel > LEVEL_FATAL) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.wtf(tag,msg);\n}\n", "raw_comment": " Send a FATAL ERROR log message", "code": "public static void f ( String msg , Object ... args ) { if ( ! allowWtf ) return ; StackTraceElement caller = getCallerStackTraceElement ( ) ; String tag = generateTag ( caller ) ; if ( sLevel > LEVEL_FATAL ) { return ; } if ( args . length > _NUM ) { msg = String . format ( msg , args ) ; } Log . wtf ( tag , msg ) ; }\n", "comment": "send a fatal error log message"}
{"id": "74215", "raw_code": "public void deleteLeaves(String name){\n  for (int i=0; i < _leaves.size(); i++) {\n    CatalogTreeLeaf leaf=_leaves.get(i);\n    if (name.equals(leaf.getName())) {\n      _leaves.remove(i);\n    }\n  }\n}\n", "raw_comment": " Leaves can be used for many-to-many relations", "code": "public void deleteLeaves ( String name ) { for ( int i = _NUM ; i < _leaves . size ( ) ; i ++ ) { CatalogTreeLeaf leaf = _leaves . get ( i ) ; if ( name . equals ( leaf . getName ( ) ) ) { _leaves . remove ( i ) ; } } }\n", "comment": "leaves can be used for many - to - many relations"}
{"id": "4673", "raw_code": "protected boolean validate(final char[] component,final int soffset,int eoffset,final BitSet generous){\n  if (eoffset == -1) {\n    eoffset=component.length - 1;\n  }\n  for (int i=soffset; i <= eoffset; i++) {\n    if (!generous.get(component[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n", "raw_comment": " Validate the URI characters within a specific component. The component must be performed after escape encoding. Or it doesn't include escaped characters. <p> It's not that much strict, generous. The strict validation might be performed before being called this method.", "code": "protected boolean validate ( final char [ ] component , final int soffset , int eoffset , final BitSet generous ) { if ( eoffset == - _NUM ) { eoffset = component . length - _NUM ; } for ( int i = soffset ; i <= eoffset ; i ++ ) { if ( ! generous . get ( component [ i ] ) ) { return _BOOL ; } } return _BOOL ; }\n", "comment": "validate the uri characters within a specific component ."}
{"id": "35618", "raw_code": "private void buildPieces(){\n  pieces=new Piece[pathArray.size()];\n  Paint paint=new Paint();\n  Matrix matrix=new Matrix();\n  Canvas canvas=new Canvas();\n  for (int i=0; i < pieces.length; i++) {\n    int shadow=Utils.nextInt(Utils.dp2px(2),Utils.dp2px(9));\n    Path path=pathArray.get(i);\n    RectF r=new RectF();\n    path.computeBounds(r,true);\n    Bitmap pBitmap=Utils.createBitmapSafely((int)r.width() + shadow * 2,(int)r.height() + shadow * 2,Bitmap.Config.ARGB_4444,1);\n    if (pBitmap == null) {\n      pieces[i]=new Piece(-1,-1,null,shadow);\n      continue;\n    }\n    pieces[i]=new Piece((int)r.left + mTouchPoint.x - shadow,(int)r.top + mTouchPoint.y - shadow,pBitmap,shadow);\n    canvas.setBitmap(pieces[i].bitmap);\n    BitmapShader mBitmapShader=new BitmapShader(mBitmap,Shader.TileMode.CLAMP,Shader.TileMode.CLAMP);\n    matrix.reset();\n    matrix.setTranslate(-r.left - offsetX + shadow,-r.top - offsetY + shadow);\n    mBitmapShader.setLocalMatrix(matrix);\n    paint.reset();\n    Path offsetPath=new Path();\n    offsetPath.addPath(path,-r.left + shadow,-r.top + shadow);\n    paint.setStyle(Paint.Style.FILL);\n    paint.setShadowLayer(shadow,0,0,0xff333333);\n    canvas.drawPath(offsetPath,paint);\n    paint.setShadowLayer(0,0,0,0);\n    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.XOR));\n    canvas.drawPath(offsetPath,paint);\n    paint.setXfermode(null);\n    paint.setShader(mBitmapShader);\n    paint.setAlpha(0xcc);\n    canvas.drawPath(offsetPath,paint);\n  }\n  Arrays.sort(pieces);\n}\n", "raw_comment": " Build the final bitmap-pieces to draw in animation", "code": "private void buildPieces ( ) { pieces = new Piece [ pathArray . size ( ) ] ; Paint paint = new Paint ( ) ; Matrix matrix = new Matrix ( ) ; Canvas canvas = new Canvas ( ) ; for ( int i = _NUM ; i < pieces . length ; i ++ ) { int shadow = Utils . nextInt ( Utils . dp2px ( _NUM ) , Utils . dp2px ( _NUM ) ) ; Path path = pathArray . get ( i ) ; RectF r = new RectF ( ) ; path . computeBounds ( r , _BOOL ) ; Bitmap pBitmap = Utils . createBitmapSafely ( ( int ) r . width ( ) + shadow * _NUM , ( int ) r . height ( ) + shadow * _NUM , Bitmap . Config . ARGB_4444 , _NUM ) ; if ( pBitmap == null ) { pieces [ i ] = new Piece ( - _NUM , - _NUM , null , shadow ) ; continue ; } pieces [ i ] = new Piece ( ( int ) r . left + mTouchPoint . x - shadow , ( int ) r . top + mTouchPoint . y - shadow , pBitmap , shadow ) ; canvas . setBitmap ( pieces [ i ] . bitmap ) ; BitmapShader mBitmapShader = new BitmapShader ( mBitmap , Shader . TileMode . CLAMP , Shader . TileMode . CLAMP ) ; matrix . reset ( ) ; matrix . setTranslate ( - r . left - offsetX + shadow , - r . top - offsetY + shadow ) ; mBitmapShader . setLocalMatrix ( matrix ) ; paint . reset ( ) ; Path offsetPath = new Path ( ) ; offsetPath . addPath ( path , - r . left + shadow , - r . top + shadow ) ; paint . setStyle ( Paint . Style . FILL ) ; paint . setShadowLayer ( shadow , _NUM , _NUM , _NUM ) ; canvas . drawPath ( offsetPath , paint ) ; paint . setShadowLayer ( _NUM , _NUM , _NUM , _NUM ) ; paint . setXfermode ( new PorterDuffXfermode ( PorterDuff . Mode . XOR ) ) ; canvas . drawPath ( offsetPath , paint ) ; paint . setXfermode ( null ) ; paint . setShader ( mBitmapShader ) ; paint . setAlpha ( _NUM ) ; canvas . drawPath ( offsetPath , paint ) ; } Arrays . sort ( pieces ) ; }\n", "comment": "build the final bitmap - pieces to draw in animation"}
{"id": "42226", "raw_code": "public boolean removeShutdownHook(Thread hook){\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPermission(RuntimePermissionCollection.SHUTDOWN_HOOKS_PERMISSION);\n  }\n  if (hook == null)   throw new NullPointerException(\"null is not allowed here\");\n  if (VMState > 0) {\n    throw new IllegalStateException();\n  }\nsynchronized (hooksList) {\n    return hooksList.remove(hook);\n  }\n}\n", "raw_comment": " De-registers a previously-registered virtual-machine shutdown hook.", "code": "public boolean removeShutdownHook ( Thread hook ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPermission ( RuntimePermissionCollection . SHUTDOWN_HOOKS_PERMISSION ) ; } if ( hook == null ) throw new NullPointerException ( _STR ) ; if ( VMState > _NUM ) { throw new IllegalStateException ( ) ; } synchronized ( hooksList ) { return hooksList . remove ( hook ) ; } }\n", "comment": "de - registers a previously - registered virtual - machine shutdown hook ."}
{"id": "54799", "raw_code": "public void run(){\n  while (m_keyboardStream != null) {\n    try {\n      if (m_keyboardReadRequest) {\n        String s=m_keyboardStream.readLine();\n        m_keyboardInput.add(s);\n        m_keyboardReadRequest=false;\nsynchronized (this) {\n          notifyAll();\n        }\n      }\n else       try {\n        Thread.sleep(50);\n      }\n catch (      InterruptedException ie) {\n      }\n    }\n catch (    IOException io) {\n    }\n  }\n}\n", "raw_comment": " A seperate thread collects our input so that we can block in the doContinue on the main thread and then allow the user to interrupt us via keyboard input on this thread. <p/> We built the stupid thing in this manner, since readLine() will block no matter what and if we 'quit' we can't seem to kill this thread.  .close() doesn't work and Thread.stop(), etc. all fail to do the job. <p/> Thus we needed to take a request response approach so that we only block when requested to do so.", "code": "public void run ( ) { while ( m_keyboardStream != null ) { try { if ( m_keyboardReadRequest ) { String s = m_keyboardStream . readLine ( ) ; m_keyboardInput . add ( s ) ; m_keyboardReadRequest = _BOOL ; synchronized ( this ) { notifyAll ( ) ; } } else try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException ie ) { } } catch ( IOException io ) { } } }\n", "comment": "a seperate thread collects our input so that we can block in the docontinue on the main thread and then allow the user to interrupt us via keyboard input on this thread ."}
{"id": "84544", "raw_code": "public boolean boundScroll(){\n  float curScroll=getStackScroll();\n  float newScroll=getBoundedStackScroll(curScroll);\n  if (Float.compare(newScroll,curScroll) != 0) {\n    setStackScroll(newScroll);\n    return true;\n  }\n  return false;\n}\n", "raw_comment": " Bounds the current scroll if necessary", "code": "public boolean boundScroll ( ) { float curScroll = getStackScroll ( ) ; float newScroll = getBoundedStackScroll ( curScroll ) ; if ( Float . compare ( newScroll , curScroll ) != _NUM ) { setStackScroll ( newScroll ) ; return _BOOL ; } return _BOOL ; }\n", "comment": "bounds the current scroll if necessary"}
{"id": "37730", "raw_code": "@Override public AggregateableEvaluation aggregate(Evaluation evaluation){\n  m_Incorrect+=evaluation.incorrect();\n  m_Correct+=evaluation.correct();\n  m_Unclassified+=evaluation.unclassified();\n  m_MissingClass+=evaluation.m_MissingClass;\n  m_WithClass+=evaluation.m_WithClass;\n  if (evaluation.m_ConfusionMatrix != null) {\n    double[][] newMatrix=evaluation.confusionMatrix();\n    if (newMatrix != null) {\n      for (int i=0; i < m_ConfusionMatrix.length; i++) {\n        for (int j=0; j < m_ConfusionMatrix[i].length; j++) {\n          m_ConfusionMatrix[i][j]+=newMatrix[i][j];\n        }\n      }\n    }\n  }\n  double[] newClassPriors=evaluation.m_ClassPriors;\n  if (newClassPriors != null && m_ClassPriors != null) {\n    for (int i=0; i < this.m_ClassPriors.length; i++) {\n      m_ClassPriors[i]=newClassPriors[i];\n    }\n  }\n  m_ClassPriorsSum=evaluation.m_ClassPriorsSum;\n  m_TotalCost+=evaluation.totalCost();\n  m_SumErr+=evaluation.m_SumErr;\n  m_SumAbsErr+=evaluation.m_SumAbsErr;\n  m_SumSqrErr+=evaluation.m_SumSqrErr;\n  m_SumClass+=evaluation.m_SumClass;\n  m_SumSqrClass+=evaluation.m_SumSqrClass;\n  m_SumPredicted+=evaluation.m_SumPredicted;\n  m_SumSqrPredicted+=evaluation.m_SumSqrPredicted;\n  m_SumClassPredicted+=evaluation.m_SumClassPredicted;\n  m_SumPriorAbsErr+=evaluation.m_SumPriorAbsErr;\n  m_SumPriorSqrErr+=evaluation.m_SumPriorSqrErr;\n  m_SumKBInfo+=evaluation.m_SumKBInfo;\n  double[] newMarginCounts=evaluation.m_MarginCounts;\n  if (newMarginCounts != null) {\n    for (int i=0; i < m_MarginCounts.length; i++) {\n      m_MarginCounts[i]+=newMarginCounts[i];\n    }\n  }\n  m_ComplexityStatisticsAvailable=evaluation.m_ComplexityStatisticsAvailable;\n  m_CoverageStatisticsAvailable=evaluation.m_CoverageStatisticsAvailable;\n  m_SumPriorEntropy+=evaluation.m_SumPriorEntropy;\n  m_SumSchemeEntropy+=evaluation.m_SumSchemeEntropy;\n  m_TotalSizeOfRegions+=evaluation.m_TotalSizeOfRegions;\n  m_TotalCoverage+=evaluation.m_TotalCoverage;\n  ArrayList<Prediction> predsToAdd=evaluation.m_Predictions;\n  if (predsToAdd != null) {\n    if (m_Predictions == null) {\n      m_Predictions=new ArrayList<Prediction>();\n    }\n    for (int i=0; i < predsToAdd.size(); i++) {\n      m_Predictions.add(predsToAdd.get(i));\n    }\n  }\n  return this;\n}\n", "raw_comment": " Adds the statistics encapsulated in the supplied Evaluation object into this one. Does not perform any checks for compatibility between the supplied Evaluation object and this one.", "code": "@ Override public AggregateableEvaluation aggregate ( Evaluation evaluation ) { m_Incorrect += evaluation . incorrect ( ) ; m_Correct += evaluation . correct ( ) ; m_Unclassified += evaluation . unclassified ( ) ; m_MissingClass += evaluation . m_MissingClass ; m_WithClass += evaluation . m_WithClass ; if ( evaluation . m_ConfusionMatrix != null ) { double [ ] [ ] newMatrix = evaluation . confusionMatrix ( ) ; if ( newMatrix != null ) { for ( int i = _NUM ; i < m_ConfusionMatrix . length ; i ++ ) { for ( int j = _NUM ; j < m_ConfusionMatrix [ i ] . length ; j ++ ) { m_ConfusionMatrix [ i ] [ j ] += newMatrix [ i ] [ j ] ; } } } } double [ ] newClassPriors = evaluation . m_ClassPriors ; if ( newClassPriors != null && m_ClassPriors != null ) { for ( int i = _NUM ; i < this . m_ClassPriors . length ; i ++ ) { m_ClassPriors [ i ] = newClassPriors [ i ] ; } } m_ClassPriorsSum = evaluation . m_ClassPriorsSum ; m_TotalCost += evaluation . totalCost ( ) ; m_SumErr += evaluation . m_SumErr ; m_SumAbsErr += evaluation . m_SumAbsErr ; m_SumSqrErr += evaluation . m_SumSqrErr ; m_SumClass += evaluation . m_SumClass ; m_SumSqrClass += evaluation . m_SumSqrClass ; m_SumPredicted += evaluation . m_SumPredicted ; m_SumSqrPredicted += evaluation . m_SumSqrPredicted ; m_SumClassPredicted += evaluation . m_SumClassPredicted ; m_SumPriorAbsErr += evaluation . m_SumPriorAbsErr ; m_SumPriorSqrErr += evaluation . m_SumPriorSqrErr ; m_SumKBInfo += evaluation . m_SumKBInfo ; double [ ] newMarginCounts = evaluation . m_MarginCounts ; if ( newMarginCounts != null ) { for ( int i = _NUM ; i < m_MarginCounts . length ; i ++ ) { m_MarginCounts [ i ] += newMarginCounts [ i ] ; } } m_ComplexityStatisticsAvailable = evaluation . m_ComplexityStatisticsAvailable ; m_CoverageStatisticsAvailable = evaluation . m_CoverageStatisticsAvailable ; m_SumPriorEntropy += evaluation . m_SumPriorEntropy ; m_SumSchemeEntropy += evaluation . m_SumSchemeEntropy ; m_TotalSizeOfRegions += evaluation . m_TotalSizeOfRegions ; m_TotalCoverage += evaluation . m_TotalCoverage ; ArrayList < Prediction > predsToAdd = evaluation . m_Predictions ; if ( predsToAdd != null ) { if ( m_Predictions == null ) { m_Predictions = new ArrayList < Prediction > ( ) ; } for ( int i = _NUM ; i < predsToAdd . size ( ) ; i ++ ) { m_Predictions . add ( predsToAdd . get ( i ) ) ; } } return this ; }\n", "comment": "adds the statistics encapsulated in the supplied evaluation object into this one ."}
{"id": "22559", "raw_code": "public void waitForVolumesToBeVisible(CGRequestParams request){\n  scan(request.getCopies(),request.getRsets());\n}\n", "raw_comment": " scans all sites until all volumes involved in the Recoverpoint protection are visible", "code": "public void waitForVolumesToBeVisible ( CGRequestParams request ) { scan ( request . getCopies ( ) , request . getRsets ( ) ) ; }\n", "comment": "scans all sites until all volumes involved in the recoverpoint protection are visible"}
{"id": "66785", "raw_code": "public void updateView(){\n  if (fInputElement != null && fParentComposite != null) {\n    IndicatorViewState oldState=fStateMap.get(fInputElement);\n    boolean reload=fFilesToReoad.contains(fInputElement);\n    if (reload || oldState == null) {\n      JsonObject jsonObject=DroidsafePluginUtilities.parseIndicatorFile(fInputElement);\n      if (jsonObject == null)       return;\n      fFilesToReoad.remove(fInputElement);\n      fState=new IndicatorViewState(fInputElement,jsonObject,getSecuritySpec(),oldState);\n      fStateMap.put(fInputElement,fState);\n    }\n else {\n      fState=oldState;\n    }\n    setPartName(fState.indicatorType);\n    showPage(PAGE_VIEWER);\n    fTreeViewer.setInput(fState.jsonObject);\n    if (fTreeViewer.getSorter() == null)     sortByField(getSortByField());\n  }\n else {\n    setPartName(DEFAULT_PART_NAME);\n  }\n}\n", "raw_comment": " Update the content of the outline view.", "code": "public void updateView ( ) { if ( fInputElement != null && fParentComposite != null ) { IndicatorViewState oldState = fStateMap . get ( fInputElement ) ; boolean reload = fFilesToReoad . contains ( fInputElement ) ; if ( reload || oldState == null ) { JsonObject jsonObject = DroidsafePluginUtilities . parseIndicatorFile ( fInputElement ) ; if ( jsonObject == null ) return ; fFilesToReoad . remove ( fInputElement ) ; fState = new IndicatorViewState ( fInputElement , jsonObject , getSecuritySpec ( ) , oldState ) ; fStateMap . put ( fInputElement , fState ) ; } else { fState = oldState ; } setPartName ( fState . indicatorType ) ; showPage ( PAGE_VIEWER ) ; fTreeViewer . setInput ( fState . jsonObject ) ; if ( fTreeViewer . getSorter ( ) == null ) sortByField ( getSortByField ( ) ) ; } else { setPartName ( DEFAULT_PART_NAME ) ; } }\n", "comment": "update the content of the outline view ."}
{"id": "38443", "raw_code": "@Override public void paint(Graphics g){\n  g.drawImage(image,0,0,this);\n  if (!paintCalled) {\n    paintCalled=true;\nsynchronized (this) {\n      notifyAll();\n    }\n  }\n}\n", "raw_comment": " Paints the image on the window.", "code": "@ Override public void paint ( Graphics g ) { g . drawImage ( image , _NUM , _NUM , this ) ; if ( ! paintCalled ) { paintCalled = _BOOL ; synchronized ( this ) { notifyAll ( ) ; } } }\n", "comment": "paints the image on the window ."}
{"id": "38792", "raw_code": "@Override public boolean connectionAllowed(String eventName){\n  if (m_listenees.containsKey(eventName)) {\n    return false;\n  }\n  return true;\n}\n", "raw_comment": " Returns true if, at this time, the object will accept a connection with respect to the named event", "code": "@ Override public boolean connectionAllowed ( String eventName ) { if ( m_listenees . containsKey ( eventName ) ) { return _BOOL ; } return _BOOL ; }\n", "comment": "returns true if , at this time , the object will accept a connection with respect to the named event"}
{"id": "68051", "raw_code": "public boolean isPrefixed(){\n  return name.indexOf(':') >= 0;\n}\n", "raw_comment": " It returns true if the attribute is prefixed (used the \":\" character).", "code": "public boolean isPrefixed ( ) { return name . indexOf ( _STR ) >= _NUM ; }\n", "comment": "it returns true if the attribute is prefixed ( used the \" : \" character ) ."}
{"id": "71337", "raw_code": "public void releaseAnyConnection(Connection connection) throws SQLException {\n  try {\n    connection.close();\n  }\n catch (  Exception ex) {\n    throw new RuntimeException(ex);\n  }\n}\n", "raw_comment": " Release a non-shard-specific connection.", "code": "public void releaseAnyConnection ( Connection connection ) throws SQLException { try { connection . close ( ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } }\n", "comment": "release a non - shard - specific connection ."}
{"id": "50146", "raw_code": "public QuickActionView addActions(Collection<Action> actions){\n  checkShown();\n  mActions.addAll(actions);\n  return this;\n}\n", "raw_comment": " Adds a collection of actions to the QuickActionView", "code": "public QuickActionView addActions ( Collection < Action > actions ) { checkShown ( ) ; mActions . addAll ( actions ) ; return this ; }\n", "comment": "adds a collection of actions to the quickactionview"}
{"id": "81874", "raw_code": "public void addSeriesRenderer(int index,SimpleSeriesRenderer renderer){\n  mRenderers.add(index,renderer);\n}\n", "raw_comment": " Adds a simple renderer to the multiple renderer.", "code": "public void addSeriesRenderer ( int index , SimpleSeriesRenderer renderer ) { mRenderers . add ( index , renderer ) ; }\n", "comment": "adds a simple renderer to the multiple renderer ."}
{"id": "5867", "raw_code": "public static boolean copyStream(InputStream is,OutputStream os,CopyListener listener,int bufferSize) throws IOException {\n  int current=0;\n  int total=is.available();\n  if (total <= 0) {\n    total=DEFAULT_IMAGE_TOTAL_SIZE;\n  }\n  final byte[] bytes=new byte[bufferSize];\n  int count;\n  if (shouldStopLoading(listener,current,total))   return false;\n  while ((count=is.read(bytes,0,bufferSize)) != -1) {\n    os.write(bytes,0,count);\n    current+=count;\n    if (shouldStopLoading(listener,current,total))     return false;\n  }\n  os.flush();\n  return true;\n}\n", "raw_comment": " Copies stream, fires progress events by listener, can be interrupted by listener.", "code": "public static boolean copyStream ( InputStream is , OutputStream os , CopyListener listener , int bufferSize ) throws IOException { int current = _NUM ; int total = is . available ( ) ; if ( total <= _NUM ) { total = DEFAULT_IMAGE_TOTAL_SIZE ; } final byte [ ] bytes = new byte [ bufferSize ] ; int count ; if ( shouldStopLoading ( listener , current , total ) ) return _BOOL ; while ( ( count = is . read ( bytes , _NUM , bufferSize ) ) != - _NUM ) { os . write ( bytes , _NUM , count ) ; current += count ; if ( shouldStopLoading ( listener , current , total ) ) return _BOOL ; } os . flush ( ) ; return _BOOL ; }\n", "comment": "copies stream , fires progress events by listener , can be interrupted by listener ."}
{"id": "76092", "raw_code": "private float calcAngle(float value){\n  return value / mData.getYValueSum() * 360f;\n}\n", "raw_comment": " calculates the needed angle for a given value", "code": "private float calcAngle ( float value ) { return value / mData . getYValueSum ( ) * _NUM ; }\n", "comment": "calculates the needed angle for a given value"}
{"id": "81546", "raw_code": "public synchronized void returnBuf(byte[] buf){\n  if (buf == null || buf.length > mSizeLimit) {\n    return;\n  }\n  mBuffersByLastUse.add(buf);\n  int pos=Collections.binarySearch(mBuffersBySize,buf,BUF_COMPARATOR);\n  if (pos < 0) {\n    pos=-pos - 1;\n  }\n  mBuffersBySize.add(pos,buf);\n  mCurrentSize+=buf.length;\n  trim();\n}\n", "raw_comment": " Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted size.", "code": "public synchronized void returnBuf ( byte [ ] buf ) { if ( buf == null || buf . length > mSizeLimit ) { return ; } mBuffersByLastUse . add ( buf ) ; int pos = Collections . binarySearch ( mBuffersBySize , buf , BUF_COMPARATOR ) ; if ( pos < _NUM ) { pos = - pos - _NUM ; } mBuffersBySize . add ( pos , buf ) ; mCurrentSize += buf . length ; trim ( ) ; }\n", "comment": "returns a buffer to the pool , throwing away old buffers if the pool would exceed its allotted size ."}
{"id": "29719", "raw_code": "protected <T extends AbstractOptionValue<?,?>>AbstractOptions(Function<T,T> valueFilter,AbstractOptions baseOptions,Iterable<T> values){\n  requireNonNull(baseOptions,\"baseOptions\");\n  requireNonNull(valueFilter,\"valueFilter\");\n  requireNonNull(values,\"values\");\n  valueMap=new IdentityHashMap<>(baseOptions.valueMap);\n  putAll(valueFilter,StreamSupport.stream(values.spliterator(),false));\n}\n", "raw_comment": " Creates a new instance.", "code": "protected < T extends AbstractOptionValue < ? , ? > > AbstractOptions ( Function < T , T > valueFilter , AbstractOptions baseOptions , Iterable < T > values ) { requireNonNull ( baseOptions , _STR ) ; requireNonNull ( valueFilter , _STR ) ; requireNonNull ( values , _STR ) ; valueMap = new IdentityHashMap < > ( baseOptions . valueMap ) ; putAll ( valueFilter , StreamSupport . stream ( values . spliterator ( ) , _BOOL ) ) ; }\n", "comment": "creates a new instance ."}
{"id": "49792", "raw_code": "public CharSeq concat(CharSeq another){\n  return new CharSeq(str + another.str);\n}\n", "raw_comment": " Append string of the given CharSeq to this CharSeq", "code": "public CharSeq concat ( CharSeq another ) { return new CharSeq ( str + another . str ) ; }\n", "comment": "append string of the given charseq to this charseq"}
{"id": "62807", "raw_code": "@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {\n  resp.setContentType(\"text/plain\");\n  PrintWriter sendToClient=resp.getWriter();\n  for (  Video v : this.videos) {\n    sendToClient.write(v.getName() + \" : \" + v.getUrl()+ \"\\n\");\n  }\n}\n", "raw_comment": " This method processes all of the HTTP GET requests routed to the servlet by the web container. This method loops through the lists of videos that have been sent to it and generates a plain/text  list of the videos that is sent back to the client.", "code": "@ Override protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { resp . setContentType ( _STR ) ; PrintWriter sendToClient = resp . getWriter ( ) ; for ( Video v : this . videos ) { sendToClient . write ( v . getName ( ) + _STR + v . getUrl ( ) + _STR ) ; } }\n", "comment": "this method processes all of the http get requests routed to the servlet by the web container ."}
{"id": "74058", "raw_code": "protected void notifyStateChange(int oldState,int newState){\n  mState=newState;\n  if (oldState != newState) {\n    firePropertyChange(\"KnownState\",Integer.valueOf(oldState),Integer.valueOf(newState));\n  }\n}\n", "raw_comment": " Change the stored state value and do notification, but don't change anything in the hardware", "code": "protected void notifyStateChange ( int oldState , int newState ) { mState = newState ; if ( oldState != newState ) { firePropertyChange ( _STR , Integer . valueOf ( oldState ) , Integer . valueOf ( newState ) ) ; } }\n", "comment": "change the stored state value and do notification , but don ' t change anything in the hardware"}
{"id": "75393", "raw_code": "private void formatAndLogThrowable(LoggingLevel level,Color color,String msg,Throwable t){\n  if (!USE_COLORS) {\n    formatAndLogThrowable(level,msg,t);\n    return;\n  }\n  if (PhotonLogger.level.id < level.id) {\n    return;\n  }\n  LocalDateTime dateTime=LocalDateTime.now();\n  String formatted=formatLogLine(level,dateTime,msg);\n  LoggingService.logThrowable(dateTime,t,formatted,color);\n}\n", "raw_comment": " Formats and logs a message with a Throwable.", "code": "private void formatAndLogThrowable ( LoggingLevel level , Color color , String msg , Throwable t ) { if ( ! USE_COLORS ) { formatAndLogThrowable ( level , msg , t ) ; return ; } if ( PhotonLogger . level . id < level . id ) { return ; } LocalDateTime dateTime = LocalDateTime . now ( ) ; String formatted = formatLogLine ( level , dateTime , msg ) ; LoggingService . logThrowable ( dateTime , t , formatted , color ) ; }\n", "comment": "formats and logs a message with a throwable ."}
{"id": "30048", "raw_code": "public static String constructQueueRedisKey(String queueName,String shardName,int priority,PinLaterJobState state){\n  return String.format(\"%s_%s_%s.p%1d_s%1d\",PINLATER_QUEUE_KEY_PREFIX,shardName,queueName,priority,state.getValue());\n}\n", "raw_comment": " Constructs the redis queue sorted set key name given a queue name, shard id and priority.", "code": "public static String constructQueueRedisKey ( String queueName , String shardName , int priority , PinLaterJobState state ) { return String . format ( _STR , PINLATER_QUEUE_KEY_PREFIX , shardName , queueName , priority , state . getValue ( ) ) ; }\n", "comment": "constructs the redis queue sorted set key name given a queue name , shard id and priority ."}
{"id": "14909", "raw_code": "public static String decodeCharset(String s,String charset){\n  if (s == null) {\n    return null;\n  }\n  try {\n    byte buf[]=s.getBytes(ASCII_CHARSET);\n    return (new String(buf,0,buf.length,charset));\n  }\n catch (  UnsupportedEncodingException uee) {\n    return s;\n  }\n}\n", "raw_comment": " Decodes the string into specified charset", "code": "public static String decodeCharset ( String s , String charset ) { if ( s == null ) { return null ; } try { byte buf [ ] = s . getBytes ( ASCII_CHARSET ) ; return ( new String ( buf , _NUM , buf . length , charset ) ) ; } catch ( UnsupportedEncodingException uee ) { return s ; } }\n", "comment": "decodes the string into specified charset"}
{"id": "67362", "raw_code": "public void addRestrictedDomain(String domainName){\n  if (StringUtils.isEmpty(domainName)) {\n    return;\n  }\n  if (restrictedDomains == null) {\n    restrictedDomains=new ArrayList<>();\n  }\n  restrictedDomains.add(domainName);\n}\n", "raw_comment": " Adds specified domain name to the list of restricted domains", "code": "public void addRestrictedDomain ( String domainName ) { if ( StringUtils . isEmpty ( domainName ) ) { return ; } if ( restrictedDomains == null ) { restrictedDomains = new ArrayList < > ( ) ; } restrictedDomains . add ( domainName ) ; }\n", "comment": "adds specified domain name to the list of restricted domains"}
{"id": "23610", "raw_code": "StoppableReadLock(ReadWriteLock lock,CancelCriterion stopper){\n  this.lock=lock.readLock();\n  this.stopper=stopper;\n}\n", "raw_comment": " Create a new read lock from the given lock", "code": "StoppableReadLock ( ReadWriteLock lock , CancelCriterion stopper ) { this . lock = lock . readLock ( ) ; this . stopper = stopper ; }\n", "comment": "create a new read lock from the given lock"}
{"id": "19112", "raw_code": "public void testisAutoIncrement(){\n  try {\n    assertFalse(rsmd.isAutoIncrement(1));\n  }\n catch (  SQLException e1) {\n    fail(\"ResultSetMetaDataTest.testGetScale()\" + e1.getMessage());\n    e1.printStackTrace();\n  }\n  try {\n    conn.close();\n    rsmd.getSchemaName(2);\n    fail(\"Exception expected\");\n  }\n catch (  SQLException e) {\n  }\n}\n", "raw_comment": " Tests fail: always returns false, failing statements commented out. Feature only partially implemented.Missing: Test positive case Not supported.", "code": "public void testisAutoIncrement ( ) { try { assertFalse ( rsmd . isAutoIncrement ( _NUM ) ) ; } catch ( SQLException e1 ) { fail ( _STR + e1 . getMessage ( ) ) ; e1 . printStackTrace ( ) ; } try { conn . close ( ) ; rsmd . getSchemaName ( _NUM ) ; fail ( _STR ) ; } catch ( SQLException e ) { } }\n", "comment": "tests fail : always returns false , failing statements commented out ."}
{"id": "48956", "raw_code": "private long computeInterfaceHash(){\n  long hash=0;\n  ByteArrayOutputStream sink=new ByteArrayOutputStream(512);\n  try {\n    MessageDigest md=MessageDigest.getInstance(\"SHA\");\n    DataOutputStream out=new DataOutputStream(new DigestOutputStream(sink,md));\n    out.writeInt(INTERFACE_HASH_STUB_VERSION);\n    for (    Method method : remoteMethods) {\n      MethodDoc methodDoc=method.methodDoc();\n      out.writeUTF(methodDoc.name());\n      out.writeUTF(Util.methodDescriptorOf(methodDoc));\n      ClassDoc exceptions[]=methodDoc.thrownExceptions();\n      Arrays.sort(exceptions,new ClassDocComparator());\n      for (      ClassDoc ex : exceptions) {\n        out.writeUTF(Util.binaryNameOf(ex));\n      }\n    }\n    out.flush();\n    byte hashArray[]=md.digest();\n    for (int i=0; i < Math.min(8,hashArray.length); i++) {\n      hash+=((long)(hashArray[i] & 0xFF)) << (i * 8);\n    }\n  }\n catch (  IOException e) {\n    throw new AssertionError(e);\n  }\ncatch (  NoSuchAlgorithmException e) {\n    throw new AssertionError(e);\n  }\n  return hash;\n}\n", "raw_comment": " Computes the \"interface hash\" of the stub/skeleton pair for this remote implementation class.  This is the 64-bit value used to enforce compatibility between a stub class and a skeleton class in the JDK 1.1 version of the JRMP stub/skeleton protocol. It is calculated using the first 64 bits of an SHA digest.  The digest is of a stream consisting of the following data: (int) stub version number, always 1 for each remote method, in order of operation number: (UTF-8) method name (UTF-8) method descriptor for each declared exception, in alphabetical name order: (UTF-8) name of exception class (where \"UTF-8\" includes a 16-bit length prefix as written by java.io.DataOutput.writeUTF).", "code": "private long computeInterfaceHash ( ) { long hash = _NUM ; ByteArrayOutputStream sink = new ByteArrayOutputStream ( _NUM ) ; try { MessageDigest md = MessageDigest . getInstance ( _STR ) ; DataOutputStream out = new DataOutputStream ( new DigestOutputStream ( sink , md ) ) ; out . writeInt ( INTERFACE_HASH_STUB_VERSION ) ; for ( Method method : remoteMethods ) { MethodDoc methodDoc = method . methodDoc ( ) ; out . writeUTF ( methodDoc . name ( ) ) ; out . writeUTF ( Util . methodDescriptorOf ( methodDoc ) ) ; ClassDoc exceptions [ ] = methodDoc . thrownExceptions ( ) ; Arrays . sort ( exceptions , new ClassDocComparator ( ) ) ; for ( ClassDoc ex : exceptions ) { out . writeUTF ( Util . binaryNameOf ( ex ) ) ; } } out . flush ( ) ; byte hashArray [ ] = md . digest ( ) ; for ( int i = _NUM ; i < Math . min ( _NUM , hashArray . length ) ; i ++ ) { hash += ( ( long ) ( hashArray [ i ] & _NUM ) ) << ( i * _NUM ) ; } } catch ( IOException e ) { throw new AssertionError ( e ) ; } catch ( NoSuchAlgorithmException e ) { throw new AssertionError ( e ) ; } return hash ; }\n", "comment": "computes the \" interface hash \" of the stub / skeleton pair for this remote implementation class ."}
{"id": "50411", "raw_code": "public static void copy(byte[] in,OutputStream out) throws IOException {\n  Assert.notNull(in,\"No input byte array specified\");\n  Assert.notNull(out,\"No OutputStream specified\");\n  out.write(in);\n}\n", "raw_comment": " Copy the contents of the given byte array to the given OutputStream. Leaves the stream open when done.", "code": "public static void copy ( byte [ ] in , OutputStream out ) throws IOException { Assert . notNull ( in , _STR ) ; Assert . notNull ( out , _STR ) ; out . write ( in ) ; }\n", "comment": "copy the contents of the given byte array to the given outputstream ."}
{"id": "33320", "raw_code": "public boolean isEmpty(){\n  return items.isEmpty();\n}\n", "raw_comment": " Returns true whether this page doesn't contain items, returns false if it does. ", "code": "public boolean isEmpty ( ) { return items . isEmpty ( ) ; }\n", "comment": "returns true whether this page doesn ' t contain items , returns false if it does ."}
{"id": "31500", "raw_code": "private static int encodeText(CharSequence msg,int startpos,int count,StringBuilder sb,int initialSubmode){\n  StringBuilder tmp=new StringBuilder(count);\n  int submode=initialSubmode;\n  int idx=0;\n  while (true) {\n    char ch=msg.charAt(startpos + idx);\nswitch (submode) {\ncase SUBMODE_ALPHA:\n      if (isAlphaUpper(ch)) {\n        if (ch == ' ') {\n          tmp.append((char)26);\n        }\n else {\n          tmp.append((char)(ch - 65));\n        }\n      }\n else {\n        if (isAlphaLower(ch)) {\n          submode=SUBMODE_LOWER;\n          tmp.append((char)27);\n          continue;\n        }\n else         if (isMixed(ch)) {\n          submode=SUBMODE_MIXED;\n          tmp.append((char)28);\n          continue;\n        }\n else {\n          tmp.append((char)29);\n          tmp.append((char)PUNCTUATION[ch]);\n          break;\n        }\n      }\n    break;\ncase SUBMODE_LOWER:\n  if (isAlphaLower(ch)) {\n    if (ch == ' ') {\n      tmp.append((char)26);\n    }\n else {\n      tmp.append((char)(ch - 97));\n    }\n  }\n else {\n    if (isAlphaUpper(ch)) {\n      tmp.append((char)27);\n      tmp.append((char)(ch - 65));\n      break;\n    }\n else     if (isMixed(ch)) {\n      submode=SUBMODE_MIXED;\n      tmp.append((char)28);\n      continue;\n    }\n else {\n      tmp.append((char)29);\n      tmp.append((char)PUNCTUATION[ch]);\n      break;\n    }\n  }\nbreak;\ncase SUBMODE_MIXED:\nif (isMixed(ch)) {\ntmp.append((char)MIXED[ch]);\n}\n else {\nif (isAlphaUpper(ch)) {\n  submode=SUBMODE_ALPHA;\n  tmp.append((char)28);\n  continue;\n}\n else if (isAlphaLower(ch)) {\n  submode=SUBMODE_LOWER;\n  tmp.append((char)27);\n  continue;\n}\n else {\n  if (startpos + idx + 1 < count) {\n    char next=msg.charAt(startpos + idx + 1);\n    if (isPunctuation(next)) {\n      submode=SUBMODE_PUNCTUATION;\n      tmp.append((char)25);\n      continue;\n    }\n  }\n  tmp.append((char)29);\n  tmp.append((char)PUNCTUATION[ch]);\n}\n}\nbreak;\ndefault :\nif (isPunctuation(ch)) {\ntmp.append((char)PUNCTUATION[ch]);\n}\n else {\nsubmode=SUBMODE_ALPHA;\ntmp.append((char)29);\ncontinue;\n}\n}\nidx++;\nif (idx >= count) {\nbreak;\n}\n}\nchar h=0;\nint len=tmp.length();\nfor (int i=0; i < len; i++) {\nboolean odd=(i % 2) != 0;\nif (odd) {\nh=(char)((h * 30) + tmp.charAt(i));\nsb.append(h);\n}\n else {\nh=tmp.charAt(i);\n}\n}\nif ((len % 2) != 0) {\nsb.append((char)((h * 30) + 29));\n}\nreturn submode;\n}\n", "raw_comment": " Encode parts of the message using Text Compaction as described in ISO/IEC 15438:2001(E), chapter 4.4.2.", "code": "private static int encodeText ( CharSequence msg , int startpos , int count , StringBuilder sb , int initialSubmode ) { StringBuilder tmp = new StringBuilder ( count ) ; int submode = initialSubmode ; int idx = _NUM ; while ( _BOOL ) { char ch = msg . charAt ( startpos + idx ) ; switch ( submode ) { case SUBMODE_ALPHA : if ( isAlphaUpper ( ch ) ) { if ( ch == _STR ) { tmp . append ( ( char ) _NUM ) ; } else { tmp . append ( ( char ) ( ch - _NUM ) ) ; } } else { if ( isAlphaLower ( ch ) ) { submode = SUBMODE_LOWER ; tmp . append ( ( char ) _NUM ) ; continue ; } else if ( isMixed ( ch ) ) { submode = SUBMODE_MIXED ; tmp . append ( ( char ) _NUM ) ; continue ; } else { tmp . append ( ( char ) _NUM ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE_LOWER : if ( isAlphaLower ( ch ) ) { if ( ch == _STR ) { tmp . append ( ( char ) _NUM ) ; } else { tmp . append ( ( char ) ( ch - _NUM ) ) ; } } else { if ( isAlphaUpper ( ch ) ) { tmp . append ( ( char ) _NUM ) ; tmp . append ( ( char ) ( ch - _NUM ) ) ; break ; } else if ( isMixed ( ch ) ) { submode = SUBMODE_MIXED ; tmp . append ( ( char ) _NUM ) ; continue ; } else { tmp . append ( ( char ) _NUM ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; break ; } } break ; case SUBMODE_MIXED : if ( isMixed ( ch ) ) { tmp . append ( ( char ) MIXED [ ch ] ) ; } else { if ( isAlphaUpper ( ch ) ) { submode = SUBMODE_ALPHA ; tmp . append ( ( char ) _NUM ) ; continue ; } else if ( isAlphaLower ( ch ) ) { submode = SUBMODE_LOWER ; tmp . append ( ( char ) _NUM ) ; continue ; } else { if ( startpos + idx + _NUM < count ) { char next = msg . charAt ( startpos + idx + _NUM ) ; if ( isPunctuation ( next ) ) { submode = SUBMODE_PUNCTUATION ; tmp . append ( ( char ) _NUM ) ; continue ; } } tmp . append ( ( char ) _NUM ) ; tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } } break ; default : if ( isPunctuation ( ch ) ) { tmp . append ( ( char ) PUNCTUATION [ ch ] ) ; } else { submode = SUBMODE_ALPHA ; tmp . append ( ( char ) _NUM ) ; continue ; } } idx ++ ; if ( idx >= count ) { break ; } } char h = _NUM ; int len = tmp . length ( ) ; for ( int i = _NUM ; i < len ; i ++ ) { boolean odd = ( i % _NUM ) != _NUM ; if ( odd ) { h = ( char ) ( ( h * _NUM ) + tmp . charAt ( i ) ) ; sb . append ( h ) ; } else { h = tmp . charAt ( i ) ; } } if ( ( len % _NUM ) != _NUM ) { sb . append ( ( char ) ( ( h * _NUM ) + _NUM ) ) ; } return submode ; }\n", "comment": "encode parts of the message using text compaction as described in iso / iec 15438 : 2001 ( e ) , chapter 4 . 4 . 2 ."}
{"id": "58189", "raw_code": "public static boolean isValidNCName(String ncName){\n  if (ncName.length() == 0)   return false;\n  char ch=ncName.charAt(0);\n  if (isNCNameStart(ch) == false)   return false;\n  for (int i=1; i < ncName.length(); i++) {\n    ch=ncName.charAt(i);\n    if (isNCName(ch) == false) {\n      return false;\n    }\n  }\n  return true;\n}\n", "raw_comment": " Check to see if a string is a valid NCName according to [4] from the XML Namespaces 1.0 Recommendation", "code": "public static boolean isValidNCName ( String ncName ) { if ( ncName . length ( ) == _NUM ) return _BOOL ; char ch = ncName . charAt ( _NUM ) ; if ( isNCNameStart ( ch ) == _BOOL ) return _BOOL ; for ( int i = _NUM ; i < ncName . length ( ) ; i ++ ) { ch = ncName . charAt ( i ) ; if ( isNCName ( ch ) == _BOOL ) { return _BOOL ; } } return _BOOL ; }\n", "comment": "check to see if a string is a valid ncname according to [ 4 ] from the xml namespaces 1 . 0 recommendation"}
{"id": "33756", "raw_code": "public RepeatedFieldBuilder<MType,BType,IType> addMessage(MType message){\n  if (message == null) {\n    throw new NullPointerException();\n  }\n  ensureMutableMessageList();\n  messages.add(message);\n  if (builders != null) {\n    builders.add(null);\n  }\n  onChanged();\n  incrementModCounts();\n  return this;\n}\n", "raw_comment": " Appends the specified element to the end of this list.", "code": "public RepeatedFieldBuilder < MType , BType , IType > addMessage ( MType message ) { if ( message == null ) { throw new NullPointerException ( ) ; } ensureMutableMessageList ( ) ; messages . add ( message ) ; if ( builders != null ) { builders . add ( null ) ; } onChanged ( ) ; incrementModCounts ( ) ; return this ; }\n", "comment": "appends the specified element to the end of this list ."}
{"id": "79089", "raw_code": "protected void prepareDataSet(){\n  dataSet1=Arrays.asList(new String[]{\"a\",\"b\",\"c\"});\n  dataSet2=Arrays.asList(new String[]{\"d\",\"e\",\"f\"});\n  dataSet3=Arrays.asList(new String[]{\"b\",\"c\",\"a\",\"d\"});\n}\n", "raw_comment": " prepare the dataset required for running test cases", "code": "protected void prepareDataSet ( ) { dataSet1 = Arrays . asList ( new String [ ] { _STR , _STR , _STR } ) ; dataSet2 = Arrays . asList ( new String [ ] { _STR , _STR , _STR } ) ; dataSet3 = Arrays . asList ( new String [ ] { _STR , _STR , _STR , _STR } ) ; }\n", "comment": "prepare the dataset required for running test cases"}
{"id": "30919", "raw_code": "private ServiceRegistrar[] buildServiceRegistrar(){\n  int k=0;\n  ServiceRegistrar[] proxys=new ServiceRegistrar[proxyRegSet.size()];\n  Iterator iter=proxyRegSet.iterator();\n  while (iter.hasNext()) {\n    ProxyReg reg=(ProxyReg)iter.next();\n    proxys[k++]=reg.proxy;\n  }\n  return proxys;\n}\n", "raw_comment": " Returns array of ServiceRegistrar created from the proxyRegSet", "code": "private ServiceRegistrar [ ] buildServiceRegistrar ( ) { int k = _NUM ; ServiceRegistrar [ ] proxys = new ServiceRegistrar [ proxyRegSet . size ( ) ] ; Iterator iter = proxyRegSet . iterator ( ) ; while ( iter . hasNext ( ) ) { ProxyReg reg = ( ProxyReg ) iter . next ( ) ; proxys [ k ++ ] = reg . proxy ; } return proxys ; }\n", "comment": "returns array of serviceregistrar created from the proxyregset"}
{"id": "46842", "raw_code": "private static boolean checkValue(String val) throws MalformedObjectNameException {\n  if (val == null)   throw new NullPointerException(\"Invalid value (null)\");\n  final int len=val.length();\n  if (len == 0)   return false;\n  final char[] s=val.toCharArray();\n  final int[] result=parseValue(s,0);\n  final int endValue=result[0];\n  final boolean value_pattern=result[1] == 1;\n  if (endValue < len)   throw new MalformedObjectNameException(\"Invalid character in value: `\" + s[endValue] + \"'\");\n  return value_pattern;\n}\n", "raw_comment": " Check if the supplied value is a valid value.", "code": "private static boolean checkValue ( String val ) throws MalformedObjectNameException { if ( val == null ) throw new NullPointerException ( _STR ) ; final int len = val . length ( ) ; if ( len == _NUM ) return _BOOL ; final char [ ] s = val . toCharArray ( ) ; final int [ ] result = parseValue ( s , _NUM ) ; final int endValue = result [ _NUM ] ; final boolean value_pattern = result [ _NUM ] == _NUM ; if ( endValue < len ) throw new MalformedObjectNameException ( _STR + s [ endValue ] + _STR ) ; return value_pattern ; }\n", "comment": "check if the supplied value is a valid value ."}
{"id": "23998", "raw_code": "protected void recoverPrimary(Set excludedServers){\n  if (pool.getPoolOrCacheCancelInProgress() != null) {\n    return;\n  }\n  final boolean isDebugEnabled=logger.isDebugEnabled();\n  if (queueConnections.getPrimary() != null) {\n    if (isDebugEnabled) {\n      logger.debug(\"Primary recovery not needed\");\n    }\n    return;\n  }\n  if (isDebugEnabled) {\n    logger.debug(\"SubscriptionManager redundancy satisfier - primary endpoint has been lost. Attempting to recover\");\n  }\n  if (printRecoveringPrimary) {\n    logger.info(LocalizedMessage.create(LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_PRIMARY_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER));\n    printRecoveringPrimary=false;\n  }\n  QueueConnectionImpl newPrimary=null;\n  while (newPrimary == null && pool.getPoolOrCacheCancelInProgress() == null) {\n    List backups=queueConnections.getBackups();\n    newPrimary=promoteBackupToPrimary(backups);\n    if (newPrimary == null) {\n      break;\n    }\n    if (!addToConnectionList(newPrimary,true)) {\nsynchronized (lock) {\n        queueConnections=queueConnections.removeConnection(newPrimary);\n      }\n      newPrimary=null;\n    }\n  }\n  if (newPrimary != null) {\n    if (isDebugEnabled) {\n      logger.debug(\"SubscriptionManager redundancy satisfier - Switched backup server to primary: {}\",newPrimary.getEndpoint());\n    }\n    if (PoolImpl.AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG) {\n      ClientServerObserver bo=ClientServerObserverHolder.getInstance();\n      bo.afterPrimaryRecovered(newPrimary.getServer());\n    }\n    cqsConnected();\n    printPrimaryNotFoundError=true;\n    printRecoveringPrimary=true;\n    return;\n  }\n  while (newPrimary == null) {\n    newPrimary=createNewPrimary(excludedServers);\n    if (newPrimary == null) {\n      break;\n    }\n    if (!addToConnectionList(newPrimary,true)) {\n      excludedServers.add(newPrimary.getServer());\n      newPrimary=null;\n    }\n    if (newPrimary != null) {\n      if (isDebugEnabled) {\n        logger.debug(\"SubscriptionManager redundancy satisfier - Non backup server was made primary. Recovering interest {}\",newPrimary.getEndpoint());\n      }\n      if (!recoverInterest(newPrimary,true)) {\n        excludedServers.add(newPrimary.getServer());\n        newPrimary=null;\n      }\n      cqsConnected();\n    }\n    if (newPrimary != null && PoolImpl.AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG) {\n      ClientServerObserver bo=ClientServerObserverHolder.getInstance();\n      bo.afterPrimaryRecovered(newPrimary.getServer());\n    }\n    printPrimaryNotFoundError=true;\n    printRecoveringPrimary=true;\n    return;\n  }\n  cqsDisconnected();\n  if (isDebugEnabled) {\n    logger.debug(\"SubscriptionManager redundancy satisfier - Could not recover a new primary\");\n  }\nsynchronized (lock) {\n    queueConnections=queueConnections.setPrimaryDiscoveryFailed(null);\n    lock.notifyAll();\n  }\n}\n", "raw_comment": " Find a new primary, adding any failed servers we encounter to the excluded servers list First we try to make a backup server the primary, but if run out of backup servers we will try to find a new server.", "code": "protected void recoverPrimary ( Set excludedServers ) { if ( pool . getPoolOrCacheCancelInProgress ( ) != null ) { return ; } final boolean isDebugEnabled = logger . isDebugEnabled ( ) ; if ( queueConnections . getPrimary ( ) != null ) { if ( isDebugEnabled ) { logger . debug ( _STR ) ; } return ; } if ( isDebugEnabled ) { logger . debug ( _STR ) ; } if ( printRecoveringPrimary ) { logger . info ( LocalizedMessage . create ( LocalizedStrings . QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_PRIMARY_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER ) ) ; printRecoveringPrimary = _BOOL ; } QueueConnectionImpl newPrimary = null ; while ( newPrimary == null && pool . getPoolOrCacheCancelInProgress ( ) == null ) { List backups = queueConnections . getBackups ( ) ; newPrimary = promoteBackupToPrimary ( backups ) ; if ( newPrimary == null ) { break ; } if ( ! addToConnectionList ( newPrimary , _BOOL ) ) { synchronized ( lock ) { queueConnections = queueConnections . removeConnection ( newPrimary ) ; } newPrimary = null ; } } if ( newPrimary != null ) { if ( isDebugEnabled ) { logger . debug ( _STR , newPrimary . getEndpoint ( ) ) ; } if ( PoolImpl . AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG ) { ClientServerObserver bo = ClientServerObserverHolder . getInstance ( ) ; bo . afterPrimaryRecovered ( newPrimary . getServer ( ) ) ; } cqsConnected ( ) ; printPrimaryNotFoundError = _BOOL ; printRecoveringPrimary = _BOOL ; return ; } while ( newPrimary == null ) { newPrimary = createNewPrimary ( excludedServers ) ; if ( newPrimary == null ) { break ; } if ( ! addToConnectionList ( newPrimary , _BOOL ) ) { excludedServers . add ( newPrimary . getServer ( ) ) ; newPrimary = null ; } if ( newPrimary != null ) { if ( isDebugEnabled ) { logger . debug ( _STR , newPrimary . getEndpoint ( ) ) ; } if ( ! recoverInterest ( newPrimary , _BOOL ) ) { excludedServers . add ( newPrimary . getServer ( ) ) ; newPrimary = null ; } cqsConnected ( ) ; } if ( newPrimary != null && PoolImpl . AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG ) { ClientServerObserver bo = ClientServerObserverHolder . getInstance ( ) ; bo . afterPrimaryRecovered ( newPrimary . getServer ( ) ) ; } printPrimaryNotFoundError = _BOOL ; printRecoveringPrimary = _BOOL ; return ; } cqsDisconnected ( ) ; if ( isDebugEnabled ) { logger . debug ( _STR ) ; } synchronized ( lock ) { queueConnections = queueConnections . setPrimaryDiscoveryFailed ( null ) ; lock . notifyAll ( ) ; } }\n", "comment": "find a new primary , adding any failed servers we encounter to the excluded servers list first we try to make a backup server the primary , but if run out of backup servers we will try to find a new server ."}
{"id": "35698", "raw_code": "private synchronized void rebuildJournal() throws IOException {\n  if (journalWriter != null) {\n    journalWriter.close();\n  }\n  Writer writer=new BufferedWriter(new FileWriter(journalFileTmp),IO_BUFFER_SIZE);\n  writer.write(MAGIC);\n  writer.write(\"\\n\");\n  writer.write(VERSION_1);\n  writer.write(\"\\n\");\n  writer.write(Integer.toString(appVersion));\n  writer.write(\"\\n\");\n  writer.write(Integer.toString(valueCount));\n  writer.write(\"\\n\");\n  writer.write(\"\\n\");\n  for (  Entry entry : lruEntries.values()) {\n    if (entry.currentEditor != null) {\n      writer.write(DIRTY + ' ' + entry.key+ '\\n');\n    }\n else {\n      writer.write(CLEAN + ' ' + entry.key+ entry.getLengths()+ '\\n');\n    }\n  }\n  writer.close();\n  journalFileTmp.renameTo(journalFile);\n  journalWriter=new BufferedWriter(new FileWriter(journalFile,true),IO_BUFFER_SIZE);\n}\n", "raw_comment": " Creates a new journal that omits redundant information. This replaces the current journal if it exists.", "code": "private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new FileWriter ( journalFileTmp ) , IO_BUFFER_SIZE ) ; writer . write ( MAGIC ) ; writer . write ( _STR ) ; writer . write ( VERSION_1 ) ; writer . write ( _STR ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( _STR ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( _STR ) ; writer . write ( _STR ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + _STR + entry . key + _STR ) ; } else { writer . write ( CLEAN + _STR + entry . key + entry . getLengths ( ) + _STR ) ; } } writer . close ( ) ; journalFileTmp . renameTo ( journalFile ) ; journalWriter = new BufferedWriter ( new FileWriter ( journalFile , _BOOL ) , IO_BUFFER_SIZE ) ; }\n", "comment": "creates a new journal that omits redundant information ."}
{"id": "26525", "raw_code": "public void remove() throws RecurrenceInfoException {\n  List<RecurrenceRule> rulesList=new ArrayList<RecurrenceRule>();\n  rulesList.addAll(rRulesList);\n  rulesList.addAll(eRulesList);\n  try {\n    for (    RecurrenceRule rule : rulesList)     rule.remove();\n    info.remove();\n  }\n catch (  RecurrenceRuleException rre) {\n    throw new RecurrenceInfoException(rre.getMessage(),rre);\n  }\ncatch (  GenericEntityException gee) {\n    throw new RecurrenceInfoException(gee.getMessage(),gee);\n  }\n}\n", "raw_comment": " Removes the recurrence from persistant store. ", "code": "public void remove ( ) throws RecurrenceInfoException { List < RecurrenceRule > rulesList = new ArrayList < RecurrenceRule > ( ) ; rulesList . addAll ( rRulesList ) ; rulesList . addAll ( eRulesList ) ; try { for ( RecurrenceRule rule : rulesList ) rule . remove ( ) ; info . remove ( ) ; } catch ( RecurrenceRuleException rre ) { throw new RecurrenceInfoException ( rre . getMessage ( ) , rre ) ; } catch ( GenericEntityException gee ) { throw new RecurrenceInfoException ( gee . getMessage ( ) , gee ) ; } }\n", "comment": "removes the recurrence from persistant store ."}
{"id": "61283", "raw_code": "public void addNodesInDocOrder(DTMIterator iterator,XPathContext support){\n  if (!m_mutable)   throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE,null));\n  int node;\n  while (DTM.NULL != (node=iterator.nextNode())) {\n    addNodeInDocOrder(node,support);\n  }\n}\n", "raw_comment": " Copy NodeList members into this nodelist, adding in document order.  If a node is null, don't add it.", "code": "public void addNodesInDocOrder ( DTMIterator iterator , XPathContext support ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_NOT_MUTABLE , null ) ) ; int node ; while ( DTM . NULL != ( node = iterator . nextNode ( ) ) ) { addNodeInDocOrder ( node , support ) ; } }\n", "comment": "copy nodelist members into this nodelist , adding in document order ."}
{"id": "11867", "raw_code": "protected boolean needToRefetchData(){\n  long now=System.currentTimeMillis();\n  long last=lastDataFetchTime;\n  if ((last + fetchIntervalMillis) < now) {\n    lastDataFetchTime=now;\n    return true;\n  }\n  return false;\n}\n", "raw_comment": " Fetches data if it hasn't been fetched in a while.", "code": "protected boolean needToRefetchData ( ) { long now = System . currentTimeMillis ( ) ; long last = lastDataFetchTime ; if ( ( last + fetchIntervalMillis ) < now ) { lastDataFetchTime = now ; return _BOOL ; } return _BOOL ; }\n", "comment": "fetches data if it hasn ' t been fetched in a while ."}
{"id": "13027", "raw_code": "@Override public DocumentType createDocumentType(String qualifiedName,String publicID,String systemID){\n  checkQName(qualifiedName);\n  return new DocumentTypeImpl(null,qualifiedName,publicID,systemID);\n}\n", "raw_comment": " Introduced in DOM Level 2. <p> <p/> Creates an empty DocumentType node.", "code": "@ Override public DocumentType createDocumentType ( String qualifiedName , String publicID , String systemID ) { checkQName ( qualifiedName ) ; return new DocumentTypeImpl ( null , qualifiedName , publicID , systemID ) ; }\n", "comment": "introduced in dom level 2 ."}
{"id": "15457", "raw_code": "public void handleRequest(RequestContext rc) throws CLIException {\n  super.handleRequest(rc);\n  ldapLogin();\n  SSOToken adminSSOToken=getAdminSSOToken();\n  IOutput outputWriter=getOutputWriter();\n  String realm=getStringOptionValue(IArgument.REALM_NAME);\n  String patternType=getStringOptionValue(IArgument.AGENT_TYPE);\n  String filter=getStringOptionValue(IArgument.FILTER);\n  if (patternType == null) {\n    patternType=\"\";\n  }\n  if ((filter == null) || (filter.length() == 0)) {\n    filter=\"*\";\n  }\n  String[] params={realm,patternType,filter};\n  writeLog(LogWriter.LOG_ACCESS,Level.INFO,\"ATTEMPT_LIST_AGENTS\",params);\n  try {\n    AMIdentityRepository amir=new AMIdentityRepository(adminSSOToken,realm);\n    IdSearchResults isr=amir.searchIdentities(IdType.AGENTONLY,filter,new IdSearchControl());\n    Set results=isr.getSearchResults();\n    if ((results != null) && !results.isEmpty()) {\n      for (Iterator i=results.iterator(); i.hasNext(); ) {\n        AMIdentity amid=(AMIdentity)i.next();\n        if (!matchType(amid,patternType)) {\n          i.remove();\n        }\n      }\n    }\n    if ((results != null) && !results.isEmpty()) {\n      for (Iterator i=results.iterator(); i.hasNext(); ) {\n        AMIdentity amid=(AMIdentity)i.next();\n        Object[] args={amid.getName(),amid.getUniversalId()};\n        outputWriter.printlnMessage(MessageFormat.format(getResourceString(\"format-search-agent-results\"),args));\n      }\n    }\n else {\n      outputWriter.printlnMessage(getResourceString(\"search-agent-no-entries\"));\n    }\n    writeLog(LogWriter.LOG_ACCESS,Level.INFO,\"SUCCEED_LIST_AGENTS\",params);\n  }\n catch (  IdRepoException e) {\n    String[] args={realm,patternType,filter,e.getMessage()};\n    debugError(\"ListAgents.handleRequest\",e);\n    writeLog(LogWriter.LOG_ERROR,Level.INFO,\"FAILED_LIST_AGENTS\",args);\n    throw new CLIException(e,ExitCodes.REQUEST_CANNOT_BE_PROCESSED);\n  }\ncatch (  SSOException e) {\n    String[] args={realm,patternType,filter,e.getMessage()};\n    debugError(\"ListAgents.handleRequest\",e);\n    writeLog(LogWriter.LOG_ERROR,Level.INFO,\"FAILED_LIST_AGENTS\",args);\n    throw new CLIException(e,ExitCodes.REQUEST_CANNOT_BE_PROCESSED);\n  }\n}\n", "raw_comment": " Services a Commandline Request.", "code": "public void handleRequest ( RequestContext rc ) throws CLIException { super . handleRequest ( rc ) ; ldapLogin ( ) ; SSOToken adminSSOToken = getAdminSSOToken ( ) ; IOutput outputWriter = getOutputWriter ( ) ; String realm = getStringOptionValue ( IArgument . REALM_NAME ) ; String patternType = getStringOptionValue ( IArgument . AGENT_TYPE ) ; String filter = getStringOptionValue ( IArgument . FILTER ) ; if ( patternType == null ) { patternType = _STR ; } if ( ( filter == null ) || ( filter . length ( ) == _NUM ) ) { filter = _STR ; } String [ ] params = { realm , patternType , filter } ; writeLog ( LogWriter . LOG_ACCESS , Level . INFO , _STR , params ) ; try { AMIdentityRepository amir = new AMIdentityRepository ( adminSSOToken , realm ) ; IdSearchResults isr = amir . searchIdentities ( IdType . AGENTONLY , filter , new IdSearchControl ( ) ) ; Set results = isr . getSearchResults ( ) ; if ( ( results != null ) && ! results . isEmpty ( ) ) { for ( Iterator i = results . iterator ( ) ; i . hasNext ( ) ; ) { AMIdentity amid = ( AMIdentity ) i . next ( ) ; if ( ! matchType ( amid , patternType ) ) { i . remove ( ) ; } } } if ( ( results != null ) && ! results . isEmpty ( ) ) { for ( Iterator i = results . iterator ( ) ; i . hasNext ( ) ; ) { AMIdentity amid = ( AMIdentity ) i . next ( ) ; Object [ ] args = { amid . getName ( ) , amid . getUniversalId ( ) } ; outputWriter . printlnMessage ( MessageFormat . format ( getResourceString ( _STR ) , args ) ) ; } } else { outputWriter . printlnMessage ( getResourceString ( _STR ) ) ; } writeLog ( LogWriter . LOG_ACCESS , Level . INFO , _STR , params ) ; } catch ( IdRepoException e ) { String [ ] args = { realm , patternType , filter , e . getMessage ( ) } ; debugError ( _STR , e ) ; writeLog ( LogWriter . LOG_ERROR , Level . INFO , _STR , args ) ; throw new CLIException ( e , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } catch ( SSOException e ) { String [ ] args = { realm , patternType , filter , e . getMessage ( ) } ; debugError ( _STR , e ) ; writeLog ( LogWriter . LOG_ERROR , Level . INFO , _STR , args ) ; throw new CLIException ( e , ExitCodes . REQUEST_CANNOT_BE_PROCESSED ) ; } }\n", "comment": "services a commandline request ."}
{"id": "21029", "raw_code": "public byte[] toBytes(){\n  try {\n    ByteArrayOutputStream out=new ByteArrayOutputStream();\n    _field.store(out,null);\n    return out.toByteArray();\n  }\n catch (  IOException e) {\n    throw new IllegalStateException(e);\n  }\n}\n", "raw_comment": " Serializes this nested object into byte[]", "code": "public byte [ ] toBytes ( ) { try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; _field . store ( out , null ) ; return out . toByteArray ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } }\n", "comment": "serializes this nested object into byte [ ]"}
{"id": "6990", "raw_code": "@SuppressWarnings(\"unchecked\") public static <E extends Enum<? extends Style.HasCssName>>E fromStyleName(final String styleName,final Class<E> enumClass,final E defaultValue){\n  if (styleName == null || enumClass == null) {\n    return defaultValue;\n  }\n  for (  final Enum<? extends Style.HasCssName> constant : enumClass.getEnumConstants()) {\n    final Style.HasCssName anEnum=(Style.HasCssName)constant;\n    final String cssClass=anEnum.getCssName();\n    if (cssClass != null && StyleHelper.containsStyle(styleName,cssClass)) {\n      return (E)anEnum;\n    }\n  }\n  return defaultValue;\n}\n", "raw_comment": " Returns first enum constant found in at space-separated list of style names.", "code": "@ SuppressWarnings ( _STR ) public static < E extends Enum < ? extends Style . HasCssName > > E fromStyleName ( final String styleName , final Class < E > enumClass , final E defaultValue ) { if ( styleName == null || enumClass == null ) { return defaultValue ; } for ( final Enum < ? extends Style . HasCssName > constant : enumClass . getEnumConstants ( ) ) { final Style . HasCssName anEnum = ( Style . HasCssName ) constant ; final String cssClass = anEnum . getCssName ( ) ; if ( cssClass != null && StyleHelper . containsStyle ( styleName , cssClass ) ) { return ( E ) anEnum ; } } return defaultValue ; }\n", "comment": "returns first enum constant found in at space - separated list of style names ."}
{"id": "25459", "raw_code": "@HLEUnimplemented @HLEFunction(nid=0x3C37A7A6,version=150,checkInsideInterrupt=true) public int sceMpegNextAvcRpAu(@CheckArgument(\"checkMpegHandle\") int mpeg,int streamUid){\n  if (!streamMap.containsKey(streamUid)) {\n    log.warn(String.format(\"sceMpegNextAvcRpAu bad stream 0x%X\",streamUid));\n    return -1;\n  }\n  int result=hleMpegGetAvcAu(null);\n  if (result != 0) {\n    if (log.isDebugEnabled()) {\n      log.debug(String.format(\"sceMpegNextAvcRpAu returning 0x%08X\",result));\n    }\n    return result;\n  }\n  videoFrameCount++;\n  startedMpeg=true;\n  return 0;\n}\n", "raw_comment": " sceMpegNextAvcRpAu - skip one video frame", "code": "@ HLEUnimplemented @ HLEFunction ( nid = _NUM , version = _NUM , checkInsideInterrupt = _BOOL ) public int sceMpegNextAvcRpAu ( @ CheckArgument ( _STR ) int mpeg , int streamUid ) { if ( ! streamMap . containsKey ( streamUid ) ) { log . warn ( String . format ( _STR , streamUid ) ) ; return - _NUM ; } int result = hleMpegGetAvcAu ( null ) ; if ( result != _NUM ) { if ( log . isDebugEnabled ( ) ) { log . debug ( String . format ( _STR , result ) ) ; } return result ; } videoFrameCount ++ ; startedMpeg = _BOOL ; return _NUM ; }\n", "comment": "scempegnextavcrpau - skip one video frame"}
{"id": "21807", "raw_code": "private Map<URI,ExportMask> createExportMaskMap(Set<URI> placedMasks){\n  Map<URI,ExportMask> exportMaskMap=new HashMap<>();\n  Iterator<ExportMask> exportMaskIterator=dbClient.queryIterativeObjects(ExportMask.class,placedMasks,true);\n  while (exportMaskIterator.hasNext()) {\n    ExportMask exportMask=exportMaskIterator.next();\n    exportMaskMap.put(exportMask.getId(),exportMask);\n  }\n  return exportMaskMap;\n}\n", "raw_comment": " Given a set of ExportMask URIs, return a map of ExportMask URI to ExportMask object", "code": "private Map < URI , ExportMask > createExportMaskMap ( Set < URI > placedMasks ) { Map < URI , ExportMask > exportMaskMap = new HashMap < > ( ) ; Iterator < ExportMask > exportMaskIterator = dbClient . queryIterativeObjects ( ExportMask . class , placedMasks , _BOOL ) ; while ( exportMaskIterator . hasNext ( ) ) { ExportMask exportMask = exportMaskIterator . next ( ) ; exportMaskMap . put ( exportMask . getId ( ) , exportMask ) ; } return exportMaskMap ; }\n", "comment": "given a set of exportmask uris , return a map of exportmask uri to exportmask object"}
{"id": "63057", "raw_code": "public ImmutableArray2<K> insert(int index,K obj){\n  int len=length + 1;\n  int newLen=len;\n  boolean extendable;\n  if (index == len - 1) {\n    AtomicBoolean x=canExtend;\n    if (x != null) {\n      canExtend=null;\n      if (array.length > index && x.getAndSet(false)) {\n        array[index]=obj;\n        return new ImmutableArray2<K>(array,len,true);\n      }\n    }\n    extendable=true;\n    newLen=len + 4;\n  }\n else {\n    extendable=false;\n  }\n  @SuppressWarnings(\"unchecked\") K[] a2=(K[])new Object[newLen];\n  DataUtils.copyWithGap(array,a2,length,index);\n  a2[index]=obj;\n  return new ImmutableArray2<K>(a2,len,extendable);\n}\n", "raw_comment": " Insert an entry at this index.", "code": "public ImmutableArray2 < K > insert ( int index , K obj ) { int len = length + _NUM ; int newLen = len ; boolean extendable ; if ( index == len - _NUM ) { AtomicBoolean x = canExtend ; if ( x != null ) { canExtend = null ; if ( array . length > index && x . getAndSet ( _BOOL ) ) { array [ index ] = obj ; return new ImmutableArray2 < K > ( array , len , _BOOL ) ; } } extendable = _BOOL ; newLen = len + _NUM ; } else { extendable = _BOOL ; } @ SuppressWarnings ( _STR ) K [ ] a2 = ( K [ ] ) new Object [ newLen ] ; DataUtils . copyWithGap ( array , a2 , length , index ) ; a2 [ index ] = obj ; return new ImmutableArray2 < K > ( a2 , len , extendable ) ; }\n", "comment": "insert an entry at this index ."}
{"id": "73994", "raw_code": "public void writeNoScale(Image c,Component i){\n  if (page == null) {\n    newpage();\n  }\n  int x=x0 + width - (c.getWidth(null) + charwidth);\n  int y=y0 + (linenum * lineheight) + lineascent;\n  if (page != null && pagenum >= prFirst) {\n    page.drawImage(c,x,y,c.getWidth(null),c.getHeight(null),null);\n  }\n}\n", "raw_comment": " Write a graphic to the printout. <P> This was not in the original class, but was added afterwards by Kevin Dickerson. it is a copy of the write, but without the scaling. <P> The image is positioned on the right side of the paper, at the current height.", "code": "public void writeNoScale ( Image c , Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . getWidth ( null ) + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= prFirst ) { page . drawImage ( c , x , y , c . getWidth ( null ) , c . getHeight ( null ) , null ) ; } }\n", "comment": "write a graphic to the printout ."}
{"id": "61293", "raw_code": "public void putDocumentInCache(int n,Source source){\n  int cachedNode=getNode(source);\n  if (DTM.NULL != cachedNode) {\n    if (!(cachedNode == n))     throw new RuntimeException(\"Programmer's Error!  \" + \"putDocumentInCache found reparse of doc: \" + source.getSystemId());\n    return;\n  }\n  if (null != source.getSystemId()) {\n    m_sourceTree.addElement(new SourceTree(n,source.getSystemId()));\n  }\n}\n", "raw_comment": " Put the source tree root node in the document cache. TODO: This function needs to be a LOT more sophisticated.", "code": "public void putDocumentInCache ( int n , Source source ) { int cachedNode = getNode ( source ) ; if ( DTM . NULL != cachedNode ) { if ( ! ( cachedNode == n ) ) throw new RuntimeException ( _STR + _STR + source . getSystemId ( ) ) ; return ; } if ( null != source . getSystemId ( ) ) { m_sourceTree . addElement ( new SourceTree ( n , source . getSystemId ( ) ) ) ; } }\n", "comment": "put the source tree root node in the document cache ."}
{"id": "50528", "raw_code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n", "raw_comment": " Used to communicate a progress update between a plugin tool and the main Whitebox user interface.", "code": "private void updateProgress ( String progressLabel , int progress ) { if ( myHost != null && ( ( progress != previousProgress ) || ( ! progressLabel . equals ( previousProgressLabel ) ) ) ) { myHost . updateProgress ( progressLabel , progress ) ; } previousProgress = progress ; previousProgressLabel = progressLabel ; }\n", "comment": "used to communicate a progress update between a plugin tool and the main whitebox user interface ."}
{"id": "1102", "raw_code": "public static void copy(InputStream is,Resource out,boolean closeIS) throws IOException {\n  OutputStream os=null;\n  try {\n    os=toBufferedOutputStream(out.getOutputStream());\n  }\n catch (  IOException ioe) {\n    IOUtil.closeEL(os);\n    throw ioe;\n  }\n  copy(is,os,closeIS,true);\n}\n", "raw_comment": " copy a input resource to a output resource", "code": "public static void copy ( InputStream is , Resource out , boolean closeIS ) throws IOException { OutputStream os = null ; try { os = toBufferedOutputStream ( out . getOutputStream ( ) ) ; } catch ( IOException ioe ) { IOUtil . closeEL ( os ) ; throw ioe ; } copy ( is , os , closeIS , _BOOL ) ; }\n", "comment": "copy a input resource to a output resource"}
{"id": "43774", "raw_code": "public String fadeAudio(String path,String type,double fadeInLength,double stopTime,double fadeOutLength) throws IOException {\n  final List<String> curves=Arrays.asList(new String[]{\"q\",\"h\",\"t\",\"l\",\"p\"});\n  if (!curves.contains(type)) {\n    throw new RuntimeException(\"fadeAudio: passed invalid type: \" + type);\n  }\n  File file=new File(path);\n  String outFile=file.getCanonicalPath() + \"_faded.wav\";\n  ArrayList<String> cmd=new ArrayList<String>();\n  cmd.add(soxBin);\n  cmd.add(path);\n  cmd.add(outFile);\n  cmd.add(\"fade\");\n  cmd.add(type);\n  cmd.add(fadeInLength + \"\");\n  if (stopTime != -1)   cmd.add(stopTime + \"\");\n  if (fadeOutLength != -1)   cmd.add(fadeOutLength + \"\");\n  try {\n    int rc=execSox(cmd,callback);\n    if (rc != 0) {\n      outFile=null;\n    }\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\ncatch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  return outFile;\n}\n", "raw_comment": " Fade audio file sox <path> outFile fade <type> <fadeInLength> <stopTime> <fadeOutLength>", "code": "public String fadeAudio ( String path , String type , double fadeInLength , double stopTime , double fadeOutLength ) throws IOException { final List < String > curves = Arrays . asList ( new String [ ] { _STR , _STR , _STR , _STR , _STR } ) ; if ( ! curves . contains ( type ) ) { throw new RuntimeException ( _STR + type ) ; } File file = new File ( path ) ; String outFile = file . getCanonicalPath ( ) + _STR ; ArrayList < String > cmd = new ArrayList < String > ( ) ; cmd . add ( soxBin ) ; cmd . add ( path ) ; cmd . add ( outFile ) ; cmd . add ( _STR ) ; cmd . add ( type ) ; cmd . add ( fadeInLength + _STR ) ; if ( stopTime != - _NUM ) cmd . add ( stopTime + _STR ) ; if ( fadeOutLength != - _NUM ) cmd . add ( fadeOutLength + _STR ) ; try { int rc = execSox ( cmd , callback ) ; if ( rc != _NUM ) { outFile = null ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } return outFile ; }\n", "comment": "fade audio file sox outfile fade"}
{"id": "61741", "raw_code": "public static ClassProperties loadProperties(Class[] cls,Properties properties,boolean inherit){\n  ClassProperties cp=new ClassProperties(properties);\n  for (  Class c : cls) {\n    cp.load(c,inherit);\n  }\n  return cp;\n}\n", "raw_comment": " For all the classes, loads all properties from each Class annotations for the given platform.", "code": "public static ClassProperties loadProperties ( Class [ ] cls , Properties properties , boolean inherit ) { ClassProperties cp = new ClassProperties ( properties ) ; for ( Class c : cls ) { cp . load ( c , inherit ) ; } return cp ; }\n", "comment": "for all the classes , loads all properties from each class annotations for the given platform ."}
{"id": "85085", "raw_code": "private static void fixGPSTimeStamp(XMPNode exifSchema) throws XMPException {\n  XMPNode gpsDateTime=XMPNodeUtils.findChildNode(exifSchema,\"exif:GPSTimeStamp\",false);\n  if (gpsDateTime == null) {\n    return;\n  }\n  try {\n    XMPDateTime binGPSStamp;\n    XMPDateTime binOtherDate;\n    binGPSStamp=XMPUtils.convertToDate(gpsDateTime.getValue());\n    if (binGPSStamp.getYear() != 0 || binGPSStamp.getMonth() != 0 || binGPSStamp.getDay() != 0) {\n      return;\n    }\n    XMPNode otherDate=XMPNodeUtils.findChildNode(exifSchema,\"exif:DateTimeOriginal\",false);\n    if (otherDate == null) {\n      otherDate=XMPNodeUtils.findChildNode(exifSchema,\"exif:DateTimeDigitized\",false);\n    }\n    binOtherDate=XMPUtils.convertToDate(otherDate.getValue());\n    Calendar cal=binGPSStamp.getCalendar();\n    cal.set(Calendar.YEAR,binOtherDate.getYear());\n    cal.set(Calendar.MONTH,binOtherDate.getMonth());\n    cal.set(Calendar.DAY_OF_MONTH,binOtherDate.getDay());\n    binGPSStamp=new XMPDateTimeImpl(cal);\n    gpsDateTime.setValue(XMPUtils.convertFromDate(binGPSStamp));\n  }\n catch (  XMPException e) {\n    return;\n  }\n}\n", "raw_comment": " Fixes the GPS Timestamp in EXIF.", "code": "private static void fixGPSTimeStamp ( XMPNode exifSchema ) throws XMPException { XMPNode gpsDateTime = XMPNodeUtils . findChildNode ( exifSchema , _STR , _BOOL ) ; if ( gpsDateTime == null ) { return ; } try { XMPDateTime binGPSStamp ; XMPDateTime binOtherDate ; binGPSStamp = XMPUtils . convertToDate ( gpsDateTime . getValue ( ) ) ; if ( binGPSStamp . getYear ( ) != _NUM || binGPSStamp . getMonth ( ) != _NUM || binGPSStamp . getDay ( ) != _NUM ) { return ; } XMPNode otherDate = XMPNodeUtils . findChildNode ( exifSchema , _STR , _BOOL ) ; if ( otherDate == null ) { otherDate = XMPNodeUtils . findChildNode ( exifSchema , _STR , _BOOL ) ; } binOtherDate = XMPUtils . convertToDate ( otherDate . getValue ( ) ) ; Calendar cal = binGPSStamp . getCalendar ( ) ; cal . set ( Calendar . YEAR , binOtherDate . getYear ( ) ) ; cal . set ( Calendar . MONTH , binOtherDate . getMonth ( ) ) ; cal . set ( Calendar . DAY_OF_MONTH , binOtherDate . getDay ( ) ) ; binGPSStamp = new XMPDateTimeImpl ( cal ) ; gpsDateTime . setValue ( XMPUtils . convertFromDate ( binGPSStamp ) ) ; } catch ( XMPException e ) { return ; } }\n", "comment": "fixes the gps timestamp in exif ."}
{"id": "56925", "raw_code": "protected boolean cellConsumesEventType(Cell<?> cell,String eventType){\n  Set<String> consumedEvents=cell.getConsumedEvents();\n  return consumedEvents != null && consumedEvents.contains(eventType);\n}\n", "raw_comment": " Check if a cell consumes the specified event type.", "code": "protected boolean cellConsumesEventType ( Cell < ? > cell , String eventType ) { Set < String > consumedEvents = cell . getConsumedEvents ( ) ; return consumedEvents != null && consumedEvents . contains ( eventType ) ; }\n", "comment": "check if a cell consumes the specified event type ."}
{"id": "44270", "raw_code": "public int read() throws IOException {\n  int b0=fInputStream.read();\n  if (b0 > 0x80) {\n    throw new IOException(Localizer.getMessage(\"jsp.error.xml.invalidASCII\",Integer.toString(b0)));\n  }\n  return b0;\n}\n", "raw_comment": " Read a single character.  This method will block until a character is available, an I/O error occurs, or the end of the stream is reached. <p> Subclasses that intend to support efficient single-character input should override this method.", "code": "public int read ( ) throws IOException { int b0 = fInputStream . read ( ) ; if ( b0 > _NUM ) { throw new IOException ( Localizer . getMessage ( _STR , Integer . toString ( b0 ) ) ) ; } return b0 ; }\n", "comment": "read a single character ."}
{"id": "35834", "raw_code": "protected void create_y_axis(int i){\n  Log.e(\"index vlaue\",i + \"\");\n  float ver_height=((graphheight / label_size) * i) + border;\n  if (i == largest_value_set.size() - 1)   canvas.drawLine(horstart,ver_height,width - (border),ver_height,paint);\n else   canvas.drawLine(horstart,ver_height,border,ver_height,paint);\n  paint.setColor(Color.BLACK);\n  int Y_labels=(int)size - 1 - i;\n  String y_labels=String.format(\"%.1f\",Y_labels * y_axis_ratio);\n  paint.setTextAlign(Paint.Align.RIGHT);\n  canvas.drawText(y_labels,horstart - 15,ver_height - 10,paint);\n  paint.setTextAlign(Paint.Align.LEFT);\n}\n", "raw_comment": " This function is used to plot the y axis and its breakdown with value. Uses drawLine() method to create the y axis and lines to show breakdown of y axis and drawText() method to plot labels related with breakdowns", "code": "protected void create_y_axis ( int i ) { Log . e ( _STR , i + _STR ) ; float ver_height = ( ( graphheight / label_size ) * i ) + border ; if ( i == largest_value_set . size ( ) - _NUM ) canvas . drawLine ( horstart , ver_height , width - ( border ) , ver_height , paint ) ; else canvas . drawLine ( horstart , ver_height , border , ver_height , paint ) ; paint . setColor ( Color . BLACK ) ; int Y_labels = ( int ) size - _NUM - i ; String y_labels = String . format ( _STR , Y_labels * y_axis_ratio ) ; paint . setTextAlign ( Paint . Align . RIGHT ) ; canvas . drawText ( y_labels , horstart - _NUM , ver_height - _NUM , paint ) ; paint . setTextAlign ( Paint . Align . LEFT ) ; }\n", "comment": "this function is used to plot the y axis and its breakdown with value ."}
{"id": "76471", "raw_code": "public long max(){\n  return deltaMax.get();\n}\n", "raw_comment": " Get running-maximum time-delta, in nanoseconds.", "code": "public long max ( ) { return deltaMax . get ( ) ; }\n", "comment": "get running - maximum time - delta , in nanoseconds ."}
{"id": "47690", "raw_code": "public void print(File file) throws IOException {\n  checkExec();\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPrintJobAccess();\n  }\n  checkActionSupport(Action.PRINT);\n  checkFileValidation(file);\n  peer.print(file);\n}\n", "raw_comment": " Prints a file with the native desktop printing facility, using the associated application's print command.", "code": "public void print ( File file ) throws IOException { checkExec ( ) ; SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPrintJobAccess ( ) ; } checkActionSupport ( Action . PRINT ) ; checkFileValidation ( file ) ; peer . print ( file ) ; }\n", "comment": "prints a file with the native desktop printing facility , using the associated application ' s print command ."}
{"id": "62019", "raw_code": "public void extend(RuleGrounding other){\n  if (other.isFailed()) {\n    groundings.clear();\n    return;\n  }\n  extend(other.getAlternatives());\n}\n", "raw_comment": " Extends the existing groundings with the alternative groundings", "code": "public void extend ( RuleGrounding other ) { if ( other . isFailed ( ) ) { groundings . clear ( ) ; return ; } extend ( other . getAlternatives ( ) ) ; }\n", "comment": "extends the existing groundings with the alternative groundings"}
{"id": "69160", "raw_code": "@Override public String expect(Pattern pattern){\n  final String token=read(pattern);\n  if (token == null) {\n    throw new ParserException(\"Expected pattern '\" + pattern.pattern() + \"' was not encountered in document: \"+ document);\n  }\n  return token;\n}\n", "raw_comment": " This will attempt to read string matching the given pattern from the document at the current point indicated by the cursor. If failed to do so, the method will be expected to throw an exception or take corrective measures.", "code": "@ Override public String expect ( Pattern pattern ) { final String token = read ( pattern ) ; if ( token == null ) { throw new ParserException ( _STR + pattern . pattern ( ) + _STR + document ) ; } return token ; }\n", "comment": "this will attempt to read string matching the given pattern from the document at the current point indicated by the cursor ."}
{"id": "79044", "raw_code": "private FileChannel updateCache(String filePath){\n  FileChannel fileChannel=fileNameAndStreamCache.get(filePath);\n  try {\n    if (null == fileChannel) {\n      FileInputStream stream=new FileInputStream(filePath);\n      fileChannel=stream.getChannel();\n      fileNameAndStreamCache.put(filePath,fileChannel);\n    }\n  }\n catch (  IOException e) {\n    LOGGER.error(e,e.getMessage());\n  }\n  return fileChannel;\n}\n", "raw_comment": " This method will be used to check whether stream is already present in cache or not for filepath if not present then create it and then add to cache, other wise get from cache", "code": "private FileChannel updateCache ( String filePath ) { FileChannel fileChannel = fileNameAndStreamCache . get ( filePath ) ; try { if ( null == fileChannel ) { FileInputStream stream = new FileInputStream ( filePath ) ; fileChannel = stream . getChannel ( ) ; fileNameAndStreamCache . put ( filePath , fileChannel ) ; } } catch ( IOException e ) { LOGGER . error ( e , e . getMessage ( ) ) ; } return fileChannel ; }\n", "comment": "this method will be used to check whether stream is already present in cache or not for filepath if not present then create it and then add to cache , other wise get from cache"}
{"id": "25039", "raw_code": "public void removeSwipeListener(SwipeListener listener){\n  if (mListeners == null) {\n    return;\n  }\n  mListeners.remove(listener);\n}\n", "raw_comment": " Removes a listener from the set of listeners", "code": "public void removeSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; }\n", "comment": "removes a listener from the set of listeners"}
{"id": "51480", "raw_code": "private static String descriptorForFieldSignature(String signature){\n  return signature.replace('.','/');\n}\n", "raw_comment": " Returns what the serialization specification calls \"descriptor\" given a field signature.", "code": "private static String descriptorForFieldSignature ( String signature ) { return signature . replace ( _STR , _STR ) ; }\n", "comment": "returns what the serialization specification calls \" descriptor \" given a field signature ."}
{"id": "4739", "raw_code": "public void addParameters(final NameValuePair[] parameters){\n  LOG.trace(\"enter PostMethod.addParameters(NameValuePair[])\");\n  if (parameters == null) {\n    LOG.warn(\"Attempt to addParameters(null) ignored\");\n  }\n else {\n    super.clearRequestBody();\n    for (int i=0; i < parameters.length; i++) {\n      params.add(parameters[i]);\n    }\n  }\n}\n", "raw_comment": " Adds an array of parameters to be used in the POST request body. Logs a warning if the parameters argument is null.", "code": "public void addParameters ( final NameValuePair [ ] parameters ) { LOG . trace ( _STR ) ; if ( parameters == null ) { LOG . warn ( _STR ) ; } else { super . clearRequestBody ( ) ; for ( int i = _NUM ; i < parameters . length ; i ++ ) { params . add ( parameters [ i ] ) ; } } }\n", "comment": "adds an array of parameters to be used in the post request body ."}
{"id": "42446", "raw_code": "@Pure public Atom annotationInterfaceToAnnotationClass(){\n  byte[] annotationClassName_tmp=new byte[val.length + 2];\n  System.arraycopy(val,0,annotationClassName_tmp,0,val.length - 1);\n  annotationClassName_tmp[val.length - 1]='$';\n  annotationClassName_tmp[val.length]='$';\n  annotationClassName_tmp[val.length + 1]=';';\n  return Atom.findOrCreateUtf8Atom(annotationClassName_tmp);\n}\n", "raw_comment": " Creates an annotation name from a class name. For example Lfoo.bar; becomes Lfoo.bar$$; NB in Sun VMs the annotation name of the first annotation is $Proxy1. Classpath may later rely on this to implement serialization correctly.", "code": "@ Pure public Atom annotationInterfaceToAnnotationClass ( ) { byte [ ] annotationClassName_tmp = new byte [ val . length + _NUM ] ; System . arraycopy ( val , _NUM , annotationClassName_tmp , _NUM , val . length - _NUM ) ; annotationClassName_tmp [ val . length - _NUM ] = _STR ; annotationClassName_tmp [ val . length ] = _STR ; annotationClassName_tmp [ val . length + _NUM ] = _STR ; return Atom . findOrCreateUtf8Atom ( annotationClassName_tmp ) ; }\n", "comment": "creates an annotation name from a class name ."}
{"id": "22820", "raw_code": "public boolean resourceSupportAR(Integer id){\n  if (id == null) {\n    return false;\n  }\n  return resourceSupportAR(id.intValue());\n}\n", "raw_comment": " Checks whether a given resource ID supports Advanced Reservations or not.", "code": "public boolean resourceSupportAR ( Integer id ) { if ( id == null ) { return _BOOL ; } return resourceSupportAR ( id . intValue ( ) ) ; }\n", "comment": "checks whether a given resource id supports advanced reservations or not ."}
{"id": "26272", "raw_code": "public static Map<String,Object> createElectronicText(DispatchContext dctx,Map<String,? extends Object> context){\n  Map<String,Object> result=createElectronicTextMethod(dctx,context);\n  return result;\n}\n", "raw_comment": " A service wrapper for the createElectronicTextMethod method. Forces permissions to be checked.", "code": "public static Map < String , Object > createElectronicText ( DispatchContext dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = createElectronicTextMethod ( dctx , context ) ; return result ; }\n", "comment": "a service wrapper for the createelectronictextmethod method ."}
{"id": "7228", "raw_code": "public PatternGuardExpr(String namespace,String name,Expression[] parameters,PatternExpr guarded){\n  this(namespace,name,Arrays.asList(parameters),guarded);\n}\n", "raw_comment": " Ctor - for use to create a pattern expression tree, without pattern child expression.", "code": "public PatternGuardExpr ( String namespace , String name , Expression [ ] parameters , PatternExpr guarded ) { this ( namespace , name , Arrays . asList ( parameters ) , guarded ) ; }\n", "comment": "ctor - for use to create a pattern expression tree , without pattern child expression ."}
{"id": "63797", "raw_code": "public static int intersectLineLine(Line2D a,Line2D b,Point2D intersect){\n  double a1x=a.getX1(), a1y=a.getY1();\n  double a2x=a.getX2(), a2y=a.getY2();\n  double b1x=b.getX1(), b1y=b.getY1();\n  double b2x=b.getX2(), b2y=b.getY2();\n  return intersectLineLine(a1x,a1y,a2x,a2y,b1x,b1y,b2x,b2y,intersect);\n}\n", "raw_comment": " Compute the intersection of two line segments.", "code": "public static int intersectLineLine ( Line2D a , Line2D b , Point2D intersect ) { double a1x = a . getX1 ( ) , a1y = a . getY1 ( ) ; double a2x = a . getX2 ( ) , a2y = a . getY2 ( ) ; double b1x = b . getX1 ( ) , b1y = b . getY1 ( ) ; double b2x = b . getX2 ( ) , b2y = b . getY2 ( ) ; return intersectLineLine ( a1x , a1y , a2x , a2y , b1x , b1y , b2x , b2y , intersect ) ; }\n", "comment": "compute the intersection of two line segments ."}
{"id": "14988", "raw_code": "public static Set updateAndGetRemovableOCs(Set origSet,Set removeOCs){\n  Set returnOCs=removeOCs;\n  if (removeOCs != null && !removeOCs.isEmpty()) {\n    returnOCs=new HashSet();\n    Iterator itr1=origSet.iterator();\n    while (itr1.hasNext()) {\n      String origOC=(String)itr1.next();\n      Iterator itr2=removeOCs.iterator();\n      while (itr2.hasNext()) {\n        String removeOC=(String)itr2.next();\n        if (origOC.equalsIgnoreCase(removeOC)) {\n          returnOCs.add(origOC);\n          break;\n        }\n      }\n    }\n    origSet.removeAll(returnOCs);\n  }\n  return returnOCs;\n}\n", "raw_comment": " Method which removes the specified object class from original set and returns the set of object classes that were removed.", "code": "public static Set updateAndGetRemovableOCs ( Set origSet , Set removeOCs ) { Set returnOCs = removeOCs ; if ( removeOCs != null && ! removeOCs . isEmpty ( ) ) { returnOCs = new HashSet ( ) ; Iterator itr1 = origSet . iterator ( ) ; while ( itr1 . hasNext ( ) ) { String origOC = ( String ) itr1 . next ( ) ; Iterator itr2 = removeOCs . iterator ( ) ; while ( itr2 . hasNext ( ) ) { String removeOC = ( String ) itr2 . next ( ) ; if ( origOC . equalsIgnoreCase ( removeOC ) ) { returnOCs . add ( origOC ) ; break ; } } } origSet . removeAll ( returnOCs ) ; } return returnOCs ; }\n", "comment": "method which removes the specified object class from original set and returns the set of object classes that were removed ."}
{"id": "76097", "raw_code": "protected void drawGridBackground(Canvas c){\n  if (mDrawGridBackground) {\n    c.drawRect(mViewPortHandler.getContentRect(),mGridBackgroundPaint);\n  }\n  if (mDrawBorders) {\n    c.drawRect(mViewPortHandler.getContentRect(),mBorderPaint);\n  }\n}\n", "raw_comment": " draws the grid background", "code": "protected void drawGridBackground ( Canvas c ) { if ( mDrawGridBackground ) { c . drawRect ( mViewPortHandler . getContentRect ( ) , mGridBackgroundPaint ) ; } if ( mDrawBorders ) { c . drawRect ( mViewPortHandler . getContentRect ( ) , mBorderPaint ) ; } }\n", "comment": "draws the grid background"}
{"id": "3754", "raw_code": "public ZipStreamImpl openReadImpl(PathImpl path) throws IOException {\n  String pathName=path.getPath();\n  return openReadImpl(pathName);\n}\n", "raw_comment": " Opens a stream to an entry in the jar.", "code": "public ZipStreamImpl openReadImpl ( PathImpl path ) throws IOException { String pathName = path . getPath ( ) ; return openReadImpl ( pathName ) ; }\n", "comment": "opens a stream to an entry in the jar ."}
{"id": "38212", "raw_code": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 112) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}\n", "raw_comment": " Unpacks the compressed character translation table.", "code": "private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ _NUM ] ; int i = _NUM ; int j = _NUM ; while ( i < _NUM ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > _NUM ) ; } return map ; }\n", "comment": "unpacks the compressed character translation table ."}
{"id": "59553", "raw_code": "@Override public void onTmpFilesCopied(ResultCode result){\n  dismissLoadingDialog();\n  finish();\n}\n", "raw_comment": " Process the result of CopyAndUploadContentUrisTask", "code": "@ Override public void onTmpFilesCopied ( ResultCode result ) { dismissLoadingDialog ( ) ; finish ( ) ; }\n", "comment": "process the result of copyanduploadcontenturistask"}
{"id": "11854", "raw_code": "public synchronized OMGraphicList prepare(){\n  Projection projection=getProjection();\n  boolean DEBUG_FINE=logger.isLoggable(Level.FINE);\n  if (projection == null) {\n    if (DEBUG_FINE) {\n      logger.fine(getName() + \": prepare called with null projection\");\n    }\n    return new OMGraphicList();\n  }\n  if (spatialIndex == null) {\n    if (DEBUG_FINE) {\n      logger.fine(getName() + \": spatialIndex is null!\");\n    }\n    OMGraphicList list=getList();\n    if (list != null) {\n      list.generate(projection,true);\n      return list;\n    }\n else {\n      return new OMGraphicList();\n    }\n  }\n  Point2D ul=projection.getUpperLeft();\n  Point2D lr=projection.getLowerRight();\n  double ulLat=ul.getY();\n  double ulLon=ul.getX();\n  double lrLat=lr.getY();\n  double lrLon=lr.getX();\n  OMGraphicList list=new OMGraphicList();\n  if (ProjMath.isCrossingDateline(ulLon,lrLon,projection.getScale())) {\n    if (DEBUG_FINE) {\n      logger.fine(\"ShapeLayer.computeGraphics(): Dateline is on screen\");\n    }\n    double ymin=Math.min(ulLat,lrLat);\n    double ymax=Math.max(ulLat,lrLat);\n    try {\n      list=spatialIndex.getOMGraphics(ulLon,ymin,180.0d,ymax,list,drawingAttributes,projection,coordTransform);\n      list=spatialIndex.getOMGraphics(-180.0d,ymin,lrLon,ymax,list,drawingAttributes,projection,coordTransform);\n    }\n catch (    InterruptedIOException iioe) {\n      list=null;\n    }\ncatch (    IOException ex) {\n      if (DEBUG_FINE) {\n        ex.printStackTrace();\n      }\n    }\ncatch (    FormatException fe) {\n      if (DEBUG_FINE) {\n        fe.printStackTrace();\n      }\n    }\ncatch (    NullPointerException npe) {\n      if (DEBUG_FINE) {\n        npe.printStackTrace();\n      }\n    }\n  }\n else {\n    double xmin=Math.min(ulLon,lrLon);\n    double xmax=Math.max(ulLon,lrLon);\n    double ymin=Math.min(ulLat,lrLat);\n    double ymax=Math.max(ulLat,lrLat);\n    try {\n      list=spatialIndex.getOMGraphics(xmin,ymin,xmax,ymax,list,drawingAttributes,projection,coordTransform);\n    }\n catch (    InterruptedIOException iioe) {\n      list=null;\n    }\ncatch (    java.io.IOException ex) {\n      if (DEBUG_FINE) {\n        ex.printStackTrace();\n      }\n    }\ncatch (    FormatException fe) {\n      if (DEBUG_FINE) {\n        fe.printStackTrace();\n      }\n    }\ncatch (    NullPointerException npe) {\n      if (DEBUG_FINE) {\n        npe.printStackTrace();\n      }\n    }\n  }\n  return list;\n}\n", "raw_comment": " Create the OMGraphics using the shape file and SpatialIndex.", "code": "public synchronized OMGraphicList prepare ( ) { Projection projection = getProjection ( ) ; boolean DEBUG_FINE = logger . isLoggable ( Level . FINE ) ; if ( projection == null ) { if ( DEBUG_FINE ) { logger . fine ( getName ( ) + _STR ) ; } return new OMGraphicList ( ) ; } if ( spatialIndex == null ) { if ( DEBUG_FINE ) { logger . fine ( getName ( ) + _STR ) ; } OMGraphicList list = getList ( ) ; if ( list != null ) { list . generate ( projection , _BOOL ) ; return list ; } else { return new OMGraphicList ( ) ; } } Point2D ul = projection . getUpperLeft ( ) ; Point2D lr = projection . getLowerRight ( ) ; double ulLat = ul . getY ( ) ; double ulLon = ul . getX ( ) ; double lrLat = lr . getY ( ) ; double lrLon = lr . getX ( ) ; OMGraphicList list = new OMGraphicList ( ) ; if ( ProjMath . isCrossingDateline ( ulLon , lrLon , projection . getScale ( ) ) ) { if ( DEBUG_FINE ) { logger . fine ( _STR ) ; } double ymin = Math . min ( ulLat , lrLat ) ; double ymax = Math . max ( ulLat , lrLat ) ; try { list = spatialIndex . getOMGraphics ( ulLon , ymin , _NUM , ymax , list , drawingAttributes , projection , coordTransform ) ; list = spatialIndex . getOMGraphics ( - _NUM , ymin , lrLon , ymax , list , drawingAttributes , projection , coordTransform ) ; } catch ( InterruptedIOException iioe ) { list = null ; } catch ( IOException ex ) { if ( DEBUG_FINE ) { ex . printStackTrace ( ) ; } } catch ( FormatException fe ) { if ( DEBUG_FINE ) { fe . printStackTrace ( ) ; } } catch ( NullPointerException npe ) { if ( DEBUG_FINE ) { npe . printStackTrace ( ) ; } } } else { double xmin = Math . min ( ulLon , lrLon ) ; double xmax = Math . max ( ulLon , lrLon ) ; double ymin = Math . min ( ulLat , lrLat ) ; double ymax = Math . max ( ulLat , lrLat ) ; try { list = spatialIndex . getOMGraphics ( xmin , ymin , xmax , ymax , list , drawingAttributes , projection , coordTransform ) ; } catch ( InterruptedIOException iioe ) { list = null ; } catch ( java . io . IOException ex ) { if ( DEBUG_FINE ) { ex . printStackTrace ( ) ; } } catch ( FormatException fe ) { if ( DEBUG_FINE ) { fe . printStackTrace ( ) ; } } catch ( NullPointerException npe ) { if ( DEBUG_FINE ) { npe . printStackTrace ( ) ; } } } return list ; }\n", "comment": "create the omgraphics using the shape file and spatialindex ."}
{"id": "60737", "raw_code": "static WorkQueue commonSubmitterQueue(){\n  ForkJoinPool p;\n  WorkQueue[] ws;\n  int m;\n  Submitter z;\n  return ((z=submitters.get()) != null && (p=commonPool) != null && (ws=p.workQueues) != null && (m=ws.length - 1) >= 0) ? ws[m & z.seed & SQMASK] : null;\n}\n", "raw_comment": " Returns common pool queue for a thread that has submitted at least one task.", "code": "static WorkQueue commonSubmitterQueue ( ) { ForkJoinPool p ; WorkQueue [ ] ws ; int m ; Submitter z ; return ( ( z = submitters . get ( ) ) != null && ( p = commonPool ) != null && ( ws = p . workQueues ) != null && ( m = ws . length - _NUM ) >= _NUM ) ? ws [ m & z . seed & SQMASK ] : null ; }\n", "comment": "returns common pool queue for a thread that has submitted at least one task ."}
